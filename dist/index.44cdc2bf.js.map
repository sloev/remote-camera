{"mappings":"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","sources":["<anon>","index.js","node_modules/trystero/src/index.js","node_modules/trystero/src/torrent.js","node_modules/trystero/src/room.js","node_modules/trystero/src/utils.js","node_modules/simple-peer-light/index.js","node_modules/trystero/src/crypto.js"],"sourcesContent":["/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ const $9dfd2262e4ffe054$var$MAX_BUFFERED_AMOUNT = 65536;\nconst $9dfd2262e4ffe054$var$ICECOMPLETE_TIMEOUT = 5000;\nconst $9dfd2262e4ffe054$var$CHANNEL_CLOSING_TIMEOUT = 5000;\nfunction $9dfd2262e4ffe054$var$randombytes(size) {\n    const array = new Uint8Array(size);\n    for(let i = 0; i < size; i++)array[i] = Math.random() * 256 | 0;\n    return array;\n}\nfunction $9dfd2262e4ffe054$var$getBrowserRTC() {\n    if (typeof globalThis === \"undefined\") return null;\n    const wrtc = {\n        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,\n        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,\n        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate\n    };\n    if (!wrtc.RTCPeerConnection) return null;\n    return wrtc;\n}\nfunction $9dfd2262e4ffe054$var$errCode(err, code) {\n    Object.defineProperty(err, \"code\", {\n        value: code,\n        enumerable: true,\n        configurable: true\n    });\n    return err;\n}\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction $9dfd2262e4ffe054$var$filterTrickle(sdp) {\n    return sdp.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction $9dfd2262e4ffe054$var$warn(message) {\n    console.warn(message);\n}\n/**\n * WebRTC peer connection.\n * @param {Object} opts\n */ class $9dfd2262e4ffe054$var$Peer {\n    constructor(opts = {}){\n        this._map = new Map() // for event emitter\n        ;\n        this._id = $9dfd2262e4ffe054$var$randombytes(4).toString(\"hex\").slice(0, 7);\n        this._doDebug = opts.debug;\n        this._debug(\"new peer %o\", opts);\n        this.channelName = opts.initiator ? opts.channelName || $9dfd2262e4ffe054$var$randombytes(20).toString(\"hex\") : null;\n        this.initiator = opts.initiator || false;\n        this.channelConfig = opts.channelConfig || $9dfd2262e4ffe054$var$Peer.channelConfig;\n        this.channelNegotiated = this.channelConfig.negotiated;\n        this.config = Object.assign({}, $9dfd2262e4ffe054$var$Peer.config, opts.config);\n        this.offerOptions = opts.offerOptions || {};\n        this.answerOptions = opts.answerOptions || {};\n        this.sdpTransform = opts.sdpTransform || ((sdp)=>sdp);\n        this.streams = opts.streams || (opts.stream ? [\n            opts.stream\n        ] : [] // support old \"stream\" option\n        );\n        this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n        this.iceCompleteTimeout = opts.iceCompleteTimeout || $9dfd2262e4ffe054$var$ICECOMPLETE_TIMEOUT;\n        this.destroyed = false;\n        this.destroying = false;\n        this._connected = false;\n        this.remoteAddress = undefined;\n        this.remoteFamily = undefined;\n        this.remotePort = undefined;\n        this.localAddress = undefined;\n        this.localFamily = undefined;\n        this.localPort = undefined;\n        this._wrtc = opts.wrtc && typeof opts.wrtc === \"object\" ? opts.wrtc : $9dfd2262e4ffe054$var$getBrowserRTC();\n        if (!this._wrtc) {\n            if (typeof window === \"undefined\") throw $9dfd2262e4ffe054$var$errCode(new Error(\"No WebRTC support: Specify `opts.wrtc` option in this environment\"), \"ERR_WEBRTC_SUPPORT\");\n            else throw $9dfd2262e4ffe054$var$errCode(new Error(\"No WebRTC support: Not a supported browser\"), \"ERR_WEBRTC_SUPPORT\");\n        }\n        this._pcReady = false;\n        this._channelReady = false;\n        this._iceComplete = false // ice candidate trickle done (got null candidate)\n        ;\n        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n        ;\n        this._channel = null;\n        this._pendingCandidates = [];\n        this._isNegotiating = false // is this peer waiting for negotiation to complete?\n        ;\n        this._firstNegotiation = true;\n        this._batchedNegotiation = false // batch synchronous negotiations\n        ;\n        this._queuedNegotiation = false // is there a queued negotiation request?\n        ;\n        this._sendersAwaitingStable = [];\n        this._senderMap = new Map();\n        this._closingInterval = null;\n        this._remoteTracks = [];\n        this._remoteStreams = [];\n        this._chunk = null;\n        this._cb = null;\n        this._interval = null;\n        try {\n            this._pc = new this._wrtc.RTCPeerConnection(this.config);\n        } catch (err) {\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_PC_CONSTRUCTOR\"));\n            return;\n        }\n        // We prefer feature detection whenever possible, but sometimes that's not\n        // possible for certain implementations.\n        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === \"number\";\n        this._pc.oniceconnectionstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onicegatheringstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onconnectionstatechange = ()=>{\n            this._onConnectionStateChange();\n        };\n        this._pc.onsignalingstatechange = ()=>{\n            this._onSignalingStateChange();\n        };\n        this._pc.onicecandidate = (event)=>{\n            this._onIceCandidate(event);\n        };\n        // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n        if (typeof this._pc.peerIdentity === \"object\") this._pc.peerIdentity.catch((err)=>{\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_PC_PEER_IDENTITY\"));\n        });\n        // Other spec events, unused by this implementation:\n        // - onconnectionstatechange\n        // - onicecandidateerror\n        // - onfingerprintfailure\n        // - onnegotiationneeded\n        if (this.initiator || this.channelNegotiated) this._setupData({\n            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n        });\n        else this._pc.ondatachannel = (event)=>{\n            this._setupData(event);\n        };\n        if (this.streams) this.streams.forEach((stream)=>{\n            this.addStream(stream);\n        });\n        this._pc.ontrack = (event)=>{\n            this._onTrack(event);\n        };\n        this._debug(\"initial negotiation\");\n        this._needsNegotiation();\n    }\n    get bufferSize() {\n        return this._channel && this._channel.bufferedAmount || 0;\n    }\n    // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    get connected() {\n        return this._connected && this._channel.readyState === \"open\";\n    }\n    address() {\n        return {\n            port: this.localPort,\n            family: this.localFamily,\n            address: this.localAddress\n        };\n    }\n    signal(data) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot signal after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (typeof data === \"string\") try {\n            data = JSON.parse(data);\n        } catch (err) {\n            data = {};\n        }\n        this._debug(\"signal()\");\n        if (data.renegotiate && this.initiator) {\n            this._debug(\"got request to renegotiate\");\n            this._needsNegotiation();\n        }\n        if (data.transceiverRequest && this.initiator) {\n            this._debug(\"got request for transceiver\");\n            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n        }\n        if (data.candidate) {\n            if (this._pc.remoteDescription && this._pc.remoteDescription.type) this._addIceCandidate(data.candidate);\n            else this._pendingCandidates.push(data.candidate);\n        }\n        if (data.sdp) this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(()=>{\n            if (this.destroyed) return;\n            this._pendingCandidates.forEach((candidate)=>{\n                this._addIceCandidate(candidate);\n            });\n            this._pendingCandidates = [];\n            if (this._pc.remoteDescription.type === \"offer\") this._createAnswer();\n        }).catch((err)=>{\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_SET_REMOTE_DESCRIPTION\"));\n        });\n        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"signal() called with invalid signal data\"), \"ERR_SIGNALING\"));\n    }\n    _addIceCandidate(candidate) {\n        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n        this._pc.addIceCandidate(iceCandidateObj).catch((err)=>{\n            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(\".local\")) $9dfd2262e4ffe054$var$warn(\"Ignoring unsupported ICE candidate.\");\n            else this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_ADD_ICE_CANDIDATE\"));\n        });\n    }\n    /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|string|Blob} chunk\n   */ send(chunk) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot send after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._channel.send(chunk);\n    }\n    /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */ addTransceiver(kind, init) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot addTransceiver after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTransceiver()\");\n        if (this.initiator) try {\n            this._pc.addTransceiver(kind, init);\n            this._needsNegotiation();\n        } catch (err) {\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_ADD_TRANSCEIVER\"));\n        }\n        else this.emit(\"signal\", {\n            // request initiator to renegotiate\n            type: \"transceiverRequest\",\n            transceiverRequest: {\n                kind: kind,\n                init: init\n            }\n        });\n    }\n    /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */ addStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot addStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addStream()\");\n        stream.getTracks().forEach((track)=>{\n            this.addTrack(track, stream);\n        });\n    }\n    /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ addTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot addTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTrack()\");\n        const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n        ;\n        let sender = submap.get(stream);\n        if (!sender) {\n            sender = this._pc.addTrack(track, stream);\n            submap.set(stream, sender);\n            this._senderMap.set(track, submap);\n            this._needsNegotiation();\n        } else if (sender.removed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"Track has been removed. You should enable/disable tracks that you want to re-add.\"), \"ERR_SENDER_REMOVED\");\n        else throw $9dfd2262e4ffe054$var$errCode(new Error(\"Track has already been added to that stream.\"), \"ERR_SENDER_ALREADY_ADDED\");\n    }\n    /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */ replaceTrack(oldTrack, newTrack, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot replaceTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"replaceTrack()\");\n        const submap = this._senderMap.get(oldTrack);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) throw $9dfd2262e4ffe054$var$errCode(new Error(\"Cannot replace track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        if (newTrack) this._senderMap.set(newTrack, submap);\n        if (sender.replaceTrack != null) sender.replaceTrack(newTrack);\n        else this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"replaceTrack is not supported in this browser\"), \"ERR_UNSUPPORTED_REPLACETRACK\"));\n    }\n    /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ removeTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot removeTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSender()\");\n        const submap = this._senderMap.get(track);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) throw $9dfd2262e4ffe054$var$errCode(new Error(\"Cannot remove track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        try {\n            sender.removed = true;\n            this._pc.removeTrack(sender);\n        } catch (err) {\n            if (err.name === \"NS_ERROR_UNEXPECTED\") this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n            ;\n            else this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_REMOVE_TRACK\"));\n        }\n        this._needsNegotiation();\n    }\n    /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */ removeStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot removeStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSenders()\");\n        stream.getTracks().forEach((track)=>{\n            this.removeTrack(track, stream);\n        });\n    }\n    _needsNegotiation() {\n        this._debug(\"_needsNegotiation\");\n        if (this._batchedNegotiation) return; // batch synchronous renegotiations\n        this._batchedNegotiation = true;\n        queueMicrotask(()=>{\n            this._batchedNegotiation = false;\n            if (this.initiator || !this._firstNegotiation) {\n                this._debug(\"starting batched negotiation\");\n                this.negotiate();\n            } else this._debug(\"non-initiator initial negotiation request discarded\");\n            this._firstNegotiation = false;\n        });\n    }\n    negotiate() {\n        if (this.destroying) return;\n        if (this.destroyed) throw $9dfd2262e4ffe054$var$errCode(new Error(\"cannot negotiate after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (this.initiator) {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug(\"already negotiating, queueing\");\n            } else {\n                this._debug(\"start negotiation\");\n                setTimeout(()=>{\n                    // HACK: Chrome crashes if we immediately call createOffer\n                    this._createOffer();\n                }, 0);\n            }\n        } else if (this._isNegotiating) {\n            this._queuedNegotiation = true;\n            this._debug(\"already negotiating, queueing\");\n        } else {\n            this._debug(\"requesting negotiation from initiator\");\n            this.emit(\"signal\", {\n                // request initiator to renegotiate\n                type: \"renegotiate\",\n                renegotiate: true\n            });\n        }\n        this._isNegotiating = true;\n    }\n    destroy(err) {\n        if (this.destroyed || this.destroying) return;\n        this.destroying = true;\n        this._debug(\"destroying (error: %s)\", err && (err.message || err));\n        queueMicrotask(()=>{\n            // allow events concurrent with the call to _destroy() to fire (see #692)\n            this.destroyed = true;\n            this.destroying = false;\n            this._debug(\"destroy (error: %s)\", err && (err.message || err));\n            this._connected = false;\n            this._pcReady = false;\n            this._channelReady = false;\n            this._remoteTracks = null;\n            this._remoteStreams = null;\n            this._senderMap = null;\n            clearInterval(this._closingInterval);\n            this._closingInterval = null;\n            clearInterval(this._interval);\n            this._interval = null;\n            this._chunk = null;\n            this._cb = null;\n            if (this._channel) {\n                try {\n                    this._channel.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._channel.onmessage = null;\n                this._channel.onopen = null;\n                this._channel.onclose = null;\n                this._channel.onerror = null;\n            }\n            if (this._pc) {\n                try {\n                    this._pc.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._pc.oniceconnectionstatechange = null;\n                this._pc.onicegatheringstatechange = null;\n                this._pc.onsignalingstatechange = null;\n                this._pc.onicecandidate = null;\n                this._pc.ontrack = null;\n                this._pc.ondatachannel = null;\n            }\n            this._pc = null;\n            this._channel = null;\n            if (err) this.emit(\"error\", err);\n            this.emit(\"close\");\n        });\n    }\n    _setupData(event) {\n        if (!event.channel) // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n        // which is invalid behavior. Handle it gracefully.\n        // See: https://github.com/feross/simple-peer/issues/163\n        return this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"Data channel event is missing `channel` property\"), \"ERR_DATA_CHANNEL\"));\n        this._channel = event.channel;\n        this._channel.binaryType = \"arraybuffer\";\n        if (typeof this._channel.bufferedAmountLowThreshold === \"number\") this._channel.bufferedAmountLowThreshold = $9dfd2262e4ffe054$var$MAX_BUFFERED_AMOUNT;\n        this.channelName = this._channel.label;\n        this._channel.onmessage = (event)=>{\n            this._onChannelMessage(event);\n        };\n        this._channel.onbufferedamountlow = ()=>{\n            this._onChannelBufferedAmountLow();\n        };\n        this._channel.onopen = ()=>{\n            this._onChannelOpen();\n        };\n        this._channel.onclose = ()=>{\n            this._onChannelClose();\n        };\n        this._channel.onerror = (err)=>{\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_DATA_CHANNEL\"));\n        };\n        // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n        let isClosing = false;\n        this._closingInterval = setInterval(()=>{\n            // No \"onclosing\" event\n            if (this._channel && this._channel.readyState === \"closing\") {\n                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n                ;\n                isClosing = true;\n            } else isClosing = false;\n        }, $9dfd2262e4ffe054$var$CHANNEL_CLOSING_TIMEOUT);\n    }\n    _startIceCompleteTimeout() {\n        if (this.destroyed) return;\n        if (this._iceCompleteTimer) return;\n        this._debug(\"started iceComplete timeout\");\n        this._iceCompleteTimer = setTimeout(()=>{\n            if (!this._iceComplete) {\n                this._iceComplete = true;\n                this._debug(\"iceComplete timeout completed\");\n                this.emit(\"iceTimeout\");\n                this.emit(\"_iceComplete\");\n            }\n        }, this.iceCompleteTimeout);\n    }\n    _createOffer() {\n        if (this.destroyed) return;\n        this._pc.createOffer(this.offerOptions).then((offer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) offer.sdp = $9dfd2262e4ffe054$var$filterTrickle(offer.sdp);\n            offer.sdp = this.sdpTransform(offer.sdp);\n            const sendOffer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || offer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n            };\n            const onSuccess = ()=>{\n                this._debug(\"createOffer success\");\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendOffer();\n                else this.once(\"_iceComplete\", sendOffer) // wait for candidates\n                ;\n            };\n            const onError = (err)=>{\n                this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_CREATE_OFFER\"));\n        });\n    }\n    _requestMissingTransceivers() {\n        if (this._pc.getTransceivers) this._pc.getTransceivers().forEach((transceiver)=>{\n            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n                transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n                ;\n                this.addTransceiver(transceiver.sender.track.kind);\n            }\n        });\n    }\n    _createAnswer() {\n        if (this.destroyed) return;\n        this._pc.createAnswer(this.answerOptions).then((answer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) answer.sdp = $9dfd2262e4ffe054$var$filterTrickle(answer.sdp);\n            answer.sdp = this.sdpTransform(answer.sdp);\n            const sendAnswer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || answer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n                if (!this.initiator) this._requestMissingTransceivers();\n            };\n            const onSuccess = ()=>{\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendAnswer();\n                else this.once(\"_iceComplete\", sendAnswer);\n            };\n            const onError = (err)=>{\n                this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_CREATE_ANSWER\"));\n        });\n    }\n    _onConnectionStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.connectionState === \"failed\") this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"Connection failed.\"), \"ERR_CONNECTION_FAILURE\"));\n    }\n    _onIceStateChange() {\n        if (this.destroyed) return;\n        const iceConnectionState = this._pc.iceConnectionState;\n        const iceGatheringState = this._pc.iceGatheringState;\n        this._debug(\"iceStateChange (connection: %s) (gathering: %s)\", iceConnectionState, iceGatheringState);\n        this.emit(\"iceStateChange\", iceConnectionState, iceGatheringState);\n        if (iceConnectionState === \"connected\" || iceConnectionState === \"completed\") {\n            this._pcReady = true;\n            this._maybeReady();\n        }\n        if (iceConnectionState === \"failed\") this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"Ice connection failed.\"), \"ERR_ICE_CONNECTION_FAILURE\"));\n        if (iceConnectionState === \"closed\") this.destroy($9dfd2262e4ffe054$var$errCode(new Error(\"Ice connection closed.\"), \"ERR_ICE_CONNECTION_CLOSED\"));\n    }\n    getStats(cb) {\n        // statreports can come with a value array instead of properties\n        const flattenValues = (report)=>{\n            if (Object.prototype.toString.call(report.values) === \"[object Array]\") report.values.forEach((value)=>{\n                Object.assign(report, value);\n            });\n            return report;\n        };\n        // Promise-based getStats() (standard)\n        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) this._pc.getStats().then((res)=>{\n            const reports = [];\n            res.forEach((report)=>{\n                reports.push(flattenValues(report));\n            });\n            cb(null, reports);\n        }, (err)=>cb(err));\n        else if (this._pc.getStats.length > 0) this._pc.getStats((res)=>{\n            // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n            if (this.destroyed) return;\n            const reports = [];\n            res.result().forEach((result)=>{\n                const report = {};\n                result.names().forEach((name)=>{\n                    report[name] = result.stat(name);\n                });\n                report.id = result.id;\n                report.type = result.type;\n                report.timestamp = result.timestamp;\n                reports.push(flattenValues(report));\n            });\n            cb(null, reports);\n        }, (err)=>cb(err));\n        else cb(null, []);\n    }\n    _maybeReady() {\n        this._debug(\"maybeReady pc %s channel %s\", this._pcReady, this._channelReady);\n        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n        this._connecting = true;\n        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n        const findCandidatePair = ()=>{\n            if (this.destroyed) return;\n            this.getStats((err, items)=>{\n                if (this.destroyed) return;\n                // Treat getStats error as non-fatal. It's not essential.\n                if (err) items = [];\n                const remoteCandidates = {};\n                const localCandidates = {};\n                const candidatePairs = {};\n                let foundSelectedCandidatePair = false;\n                items.forEach((item)=>{\n                    // TODO: Once all browsers support the hyphenated stats report types, remove\n                    // the non-hypenated ones\n                    if (item.type === \"remotecandidate\" || item.type === \"remote-candidate\") remoteCandidates[item.id] = item;\n                    if (item.type === \"localcandidate\" || item.type === \"local-candidate\") localCandidates[item.id] = item;\n                    if (item.type === \"candidatepair\" || item.type === \"candidate-pair\") candidatePairs[item.id] = item;\n                });\n                const setSelectedCandidatePair = (selectedCandidatePair)=>{\n                    foundSelectedCandidatePair = true;\n                    let local = localCandidates[selectedCandidatePair.localCandidateId];\n                    if (local && (local.ip || local.address)) {\n                        // Spec\n                        this.localAddress = local.ip || local.address;\n                        this.localPort = Number(local.port);\n                    } else if (local && local.ipAddress) {\n                        // Firefox\n                        this.localAddress = local.ipAddress;\n                        this.localPort = Number(local.portNumber);\n                    } else if (typeof selectedCandidatePair.googLocalAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        local = selectedCandidatePair.googLocalAddress.split(\":\");\n                        this.localAddress = local[0];\n                        this.localPort = Number(local[1]);\n                    }\n                    if (this.localAddress) this.localFamily = this.localAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n                    if (remote && (remote.ip || remote.address)) {\n                        // Spec\n                        this.remoteAddress = remote.ip || remote.address;\n                        this.remotePort = Number(remote.port);\n                    } else if (remote && remote.ipAddress) {\n                        // Firefox\n                        this.remoteAddress = remote.ipAddress;\n                        this.remotePort = Number(remote.portNumber);\n                    } else if (typeof selectedCandidatePair.googRemoteAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        remote = selectedCandidatePair.googRemoteAddress.split(\":\");\n                        this.remoteAddress = remote[0];\n                        this.remotePort = Number(remote[1]);\n                    }\n                    if (this.remoteAddress) this.remoteFamily = this.remoteAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    this._debug(\"connect local: %s:%s remote: %s:%s\", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n                };\n                items.forEach((item)=>{\n                    // Spec-compliant\n                    if (item.type === \"transport\" && item.selectedCandidatePairId) setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n                    // Old implementations\n                    if (item.type === \"googCandidatePair\" && item.googActiveConnection === \"true\" || (item.type === \"candidatepair\" || item.type === \"candidate-pair\") && item.selected) setSelectedCandidatePair(item);\n                });\n                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n                // But wait until at least 1 candidate pair is available\n                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n                    setTimeout(findCandidatePair, 100);\n                    return;\n                } else {\n                    this._connecting = false;\n                    this._connected = true;\n                }\n                if (this._chunk) {\n                    try {\n                        this.send(this._chunk);\n                    } catch (err) {\n                        return this.destroy($9dfd2262e4ffe054$var$errCode(err, \"ERR_DATA_CHANNEL\"));\n                    }\n                    this._chunk = null;\n                    this._debug('sent chunk from \"write before connect\"');\n                    const cb = this._cb;\n                    this._cb = null;\n                    cb(null);\n                }\n                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n                // fallback to using setInterval to implement backpressure.\n                if (typeof this._channel.bufferedAmountLowThreshold !== \"number\") {\n                    this._interval = setInterval(()=>this._onInterval(), 150);\n                    if (this._interval.unref) this._interval.unref();\n                }\n                this._debug(\"connect\");\n                this.emit(\"connect\");\n            });\n        };\n        findCandidatePair();\n    }\n    _onInterval() {\n        if (!this._cb || !this._channel || this._channel.bufferedAmount > $9dfd2262e4ffe054$var$MAX_BUFFERED_AMOUNT) return;\n        this._onChannelBufferedAmountLow();\n    }\n    _onSignalingStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.signalingState === \"stable\") {\n            this._isNegotiating = false;\n            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n            this._debug(\"flushing sender queue\", this._sendersAwaitingStable);\n            this._sendersAwaitingStable.forEach((sender)=>{\n                this._pc.removeTrack(sender);\n                this._queuedNegotiation = true;\n            });\n            this._sendersAwaitingStable = [];\n            if (this._queuedNegotiation) {\n                this._debug(\"flushing negotiation queue\");\n                this._queuedNegotiation = false;\n                this._needsNegotiation() // negotiate again\n                ;\n            } else {\n                this._debug(\"negotiated\");\n                this.emit(\"negotiated\");\n            }\n        }\n        this._debug(\"signalingStateChange %s\", this._pc.signalingState);\n        this.emit(\"signalingStateChange\", this._pc.signalingState);\n    }\n    _onIceCandidate(event) {\n        if (this.destroyed) return;\n        if (event.candidate && this.trickle) this.emit(\"signal\", {\n            type: \"candidate\",\n            candidate: {\n                candidate: event.candidate.candidate,\n                sdpMLineIndex: event.candidate.sdpMLineIndex,\n                sdpMid: event.candidate.sdpMid\n            }\n        });\n        else if (!event.candidate && !this._iceComplete) {\n            this._iceComplete = true;\n            this.emit(\"_iceComplete\");\n        }\n        // as soon as we've received one valid candidate start timeout\n        if (event.candidate) this._startIceCompleteTimeout();\n    }\n    _onChannelMessage(event) {\n        if (this.destroyed) return;\n        let data = event.data;\n        if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n        this.emit(\"data\", data);\n    }\n    _onChannelBufferedAmountLow() {\n        if (this.destroyed || !this._cb) return;\n        this._debug(\"ending backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n        const cb = this._cb;\n        this._cb = null;\n        cb(null);\n    }\n    _onChannelOpen() {\n        if (this._connected || this.destroyed) return;\n        this._debug(\"on channel open\");\n        this._channelReady = true;\n        this._maybeReady();\n    }\n    _onChannelClose() {\n        if (this.destroyed) return;\n        this._debug(\"on channel close\");\n        this.destroy();\n    }\n    _onTrack(event) {\n        if (this.destroyed) return;\n        event.streams.forEach((eventStream)=>{\n            this._debug(\"on track\");\n            this.emit(\"track\", event.track, eventStream);\n            this._remoteTracks.push({\n                track: event.track,\n                stream: eventStream\n            });\n            if (this._remoteStreams.some((remoteStream)=>{\n                return remoteStream.id === eventStream.id;\n            })) return;\n             // Only fire one 'stream' event, even though there may be multiple tracks per stream\n            this._remoteStreams.push(eventStream);\n            queueMicrotask(()=>{\n                this._debug(\"on stream\");\n                this.emit(\"stream\", eventStream) // ensure all tracks have been added\n                ;\n            });\n        });\n    }\n    _debug(...args) {\n        if (!this._doDebug) return;\n        args[0] = \"[\" + this._id + \"] \" + args[0];\n        console.log(...args);\n    }\n    // event emitter\n    on(key, listener) {\n        const map = this._map;\n        if (!map.has(key)) map.set(key, new Set());\n        map.get(key).add(listener);\n    }\n    off(key, listener) {\n        const map = this._map;\n        const listeners = map.get(key);\n        if (!listeners) return;\n        listeners.delete(listener);\n        if (listeners.size === 0) map.delete(key);\n    }\n    once(key, listener) {\n        const listener_ = (...args)=>{\n            this.off(key, listener_);\n            listener(...args);\n        };\n        this.on(key, listener_);\n    }\n    emit(key, ...args) {\n        const map = this._map;\n        if (!map.has(key)) return;\n        for (const listener of map.get(key))try {\n            listener(...args);\n        } catch (err) {\n            console.error(err);\n        }\n    }\n}\n$9dfd2262e4ffe054$var$Peer.WEBRTC_SUPPORT = !!$9dfd2262e4ffe054$var$getBrowserRTC();\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */ $9dfd2262e4ffe054$var$Peer.config = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:global.stun.twilio.com:3478\"\n            ]\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\n$9dfd2262e4ffe054$var$Peer.channelConfig = {};\nvar // module.exports = Peer\n$9dfd2262e4ffe054$export$2e2bcd8739ae039 = $9dfd2262e4ffe054$var$Peer;\n\n\nconst $42a97e6b757c21d9$var$charSet = \"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\";\nconst $42a97e6b757c21d9$export$faba228f15d9c316 = (initiator, trickle, config)=>{\n    const peer = new (0, $9dfd2262e4ffe054$export$2e2bcd8739ae039)({\n        initiator: initiator,\n        trickle: trickle,\n        config: config\n    });\n    const onData = (data)=>peer.__earlyDataBuffer.push(data);\n    peer.on($42a97e6b757c21d9$export$4bf9923669ad6c63.data, onData);\n    peer.__earlyDataBuffer = [];\n    peer.__drainEarlyData = (f)=>{\n        peer.off($42a97e6b757c21d9$export$4bf9923669ad6c63.data, onData);\n        peer.__earlyDataBuffer.forEach(f);\n        delete peer.__earlyDataBuffer;\n        delete peer.__drainEarlyData;\n    };\n    return peer;\n};\nconst $42a97e6b757c21d9$export$87d45d9755ebb726 = (n)=>Array(n).fill().map(()=>$42a97e6b757c21d9$var$charSet[Math.floor(Math.random() * $42a97e6b757c21d9$var$charSet.length)]).join(\"\");\nconst $42a97e6b757c21d9$export$9cc48d06fd3e6e94 = (occupiedRooms, f)=>(config, ns)=>{\n        if (occupiedRooms[ns]) return occupiedRooms[ns];\n        if (!config) throw $42a97e6b757c21d9$export$5575a5c000f2af79(\"requires a config map as the first argument\");\n        if (!config.appId && !config.firebaseApp) throw $42a97e6b757c21d9$export$5575a5c000f2af79(\"config map is missing appId field\");\n        if (!ns) throw $42a97e6b757c21d9$export$5575a5c000f2af79(\"namespace argument required\");\n        return occupiedRooms[ns] = f(config, ns);\n    };\nconst $42a97e6b757c21d9$export$cc42576d343e0f6a = \"Trystero\";\nconst $42a97e6b757c21d9$export$d01767fa86c38c2d = $42a97e6b757c21d9$export$87d45d9755ebb726(20);\nconst { keys: $42a97e6b757c21d9$export$ed97f33186d4b816, values: $42a97e6b757c21d9$export$68c286be0e7e55b7, entries: $42a97e6b757c21d9$export$3e9f948b41964866, fromEntries: $42a97e6b757c21d9$export$5150077fc2e7c662 } = Object;\nconst $42a97e6b757c21d9$export$b50b6e108474309b = ()=>{};\nconst $42a97e6b757c21d9$export$5575a5c000f2af79 = (msg)=>new Error(`${$42a97e6b757c21d9$export$cc42576d343e0f6a}: ${msg}`);\nconst $42a97e6b757c21d9$export$2589e87d78677b0d = (txt)=>new TextEncoder().encode(txt);\nconst $42a97e6b757c21d9$export$c97600adfa527f5b = (buffer)=>new TextDecoder().decode(buffer);\nconst $42a97e6b757c21d9$export$7ea66e3774a60b67 = (buffer)=>buffer.reduce((a, c)=>a + c.toString(16).padStart(2, \"0\"), \"\");\nconst $42a97e6b757c21d9$export$4bf9923669ad6c63 = $42a97e6b757c21d9$export$5150077fc2e7c662([\n    \"close\",\n    \"connect\",\n    \"data\",\n    \"error\",\n    \"signal\",\n    \"stream\",\n    \"track\"\n].map((k)=>[\n        k,\n        k\n    ]));\nconst $42a97e6b757c21d9$export$37be945df5c81949 = (config, defaults, defaultN)=>(config.relayUrls || defaults).slice(0, config.relayUrls ? config.relayUrls.length : config.relayRedundancy || defaultN);\nconst $42a97e6b757c21d9$export$e772c8ff12451969 = (ms)=>new Promise((res)=>setTimeout(res, ms));\n\n\nconst $4dd9fb32b9ed9581$var$TypedArray = Object.getPrototypeOf(Uint8Array);\nconst $4dd9fb32b9ed9581$var$typeByteLimit = 12;\nconst $4dd9fb32b9ed9581$var$typeIndex = 0;\nconst $4dd9fb32b9ed9581$var$nonceIndex = $4dd9fb32b9ed9581$var$typeIndex + $4dd9fb32b9ed9581$var$typeByteLimit;\nconst $4dd9fb32b9ed9581$var$tagIndex = $4dd9fb32b9ed9581$var$nonceIndex + 1;\nconst $4dd9fb32b9ed9581$var$progressIndex = $4dd9fb32b9ed9581$var$tagIndex + 1;\nconst $4dd9fb32b9ed9581$var$payloadIndex = $4dd9fb32b9ed9581$var$progressIndex + 1;\nconst $4dd9fb32b9ed9581$var$chunkSize = 16384 - $4dd9fb32b9ed9581$var$payloadIndex;\nconst $4dd9fb32b9ed9581$var$oneByteMax = 0xff;\nconst $4dd9fb32b9ed9581$var$buffLowEvent = \"bufferedamountlow\";\nvar $4dd9fb32b9ed9581$export$2e2bcd8739ae039 = (onPeer, onSelfLeave)=>{\n    const peerMap = {};\n    const actions = {};\n    const pendingTransmissions = {};\n    const pendingPongs = {};\n    const pendingStreamMetas = {};\n    const pendingTrackMetas = {};\n    const iterate = (targets, f)=>(targets ? Array.isArray(targets) ? targets : [\n            targets\n        ] : (0, $42a97e6b757c21d9$export$ed97f33186d4b816)(peerMap)).flatMap((id)=>{\n            const peer = peerMap[id];\n            if (!peer) {\n                console.warn(`${(0, $42a97e6b757c21d9$export$cc42576d343e0f6a)}: no peer with id ${id} found`);\n                return [];\n            }\n            return f(id, peer);\n        });\n    const exitPeer = (id)=>{\n        if (!peerMap[id]) return;\n        delete peerMap[id];\n        delete pendingTransmissions[id];\n        delete pendingPongs[id];\n        onPeerLeave(id);\n    };\n    const makeAction = (type)=>{\n        if (actions[type]) return [\n            actions[type].send,\n            actions[type].setOnComplete,\n            actions[type].setOnProgress\n        ];\n        if (!type) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"action type argument is required\");\n        const typeBytes = (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(type);\n        if (typeBytes.byteLength > $4dd9fb32b9ed9581$var$typeByteLimit) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(`action type string \"${type}\" (${typeBytes.byteLength}b) exceeds ` + `byte limit (${$4dd9fb32b9ed9581$var$typeByteLimit}). Hint: choose a shorter name.`);\n        const typeBytesPadded = new Uint8Array($4dd9fb32b9ed9581$var$typeByteLimit);\n        typeBytesPadded.set(typeBytes);\n        let nonce = 0;\n        actions[type] = {\n            onComplete: (0, $42a97e6b757c21d9$export$b50b6e108474309b),\n            onProgress: (0, $42a97e6b757c21d9$export$b50b6e108474309b),\n            setOnComplete: (f)=>actions[type] = {\n                    ...actions[type],\n                    onComplete: f\n                },\n            setOnProgress: (f)=>actions[type] = {\n                    ...actions[type],\n                    onProgress: f\n                },\n            send: async (data, targets, meta, onProgress)=>{\n                if (meta && typeof meta !== \"object\") throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"action meta argument must be an object\");\n                if (data === undefined) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"action data cannot be undefined\");\n                const isJson = typeof data !== \"string\";\n                const isBlob = data instanceof Blob;\n                const isBinary = isBlob || data instanceof ArrayBuffer || data instanceof $4dd9fb32b9ed9581$var$TypedArray;\n                if (meta && !isBinary) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"action meta argument can only be used with binary data\");\n                const buffer = isBinary ? new Uint8Array(isBlob ? await data.arrayBuffer() : data) : (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(isJson ? JSON.stringify(data) : data);\n                const metaEncoded = meta ? (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(JSON.stringify(meta)) : null;\n                const chunkTotal = Math.ceil(buffer.byteLength / $4dd9fb32b9ed9581$var$chunkSize) + (meta ? 1 : 0) || 1;\n                const chunks = Array(chunkTotal).fill().map((_, i)=>{\n                    const isLast = i === chunkTotal - 1;\n                    const isMeta = meta && i === 0;\n                    const chunk = new Uint8Array($4dd9fb32b9ed9581$var$payloadIndex + (isMeta ? metaEncoded.byteLength : isLast ? buffer.byteLength - $4dd9fb32b9ed9581$var$chunkSize * (chunkTotal - (meta ? 2 : 1)) : $4dd9fb32b9ed9581$var$chunkSize));\n                    chunk.set(typeBytesPadded);\n                    chunk.set([\n                        nonce\n                    ], $4dd9fb32b9ed9581$var$nonceIndex);\n                    chunk.set([\n                        isLast | isMeta << 1 | isBinary << 2 | isJson << 3\n                    ], $4dd9fb32b9ed9581$var$tagIndex);\n                    chunk.set([\n                        Math.round((i + 1) / chunkTotal * $4dd9fb32b9ed9581$var$oneByteMax)\n                    ], $4dd9fb32b9ed9581$var$progressIndex);\n                    chunk.set(meta ? isMeta ? metaEncoded : buffer.subarray((i - 1) * $4dd9fb32b9ed9581$var$chunkSize, i * $4dd9fb32b9ed9581$var$chunkSize) : buffer.subarray(i * $4dd9fb32b9ed9581$var$chunkSize, (i + 1) * $4dd9fb32b9ed9581$var$chunkSize), $4dd9fb32b9ed9581$var$payloadIndex);\n                    return chunk;\n                });\n                nonce = nonce + 1 & $4dd9fb32b9ed9581$var$oneByteMax;\n                return Promise.all(iterate(targets, async (id, peer)=>{\n                    const chan = peer._channel;\n                    let chunkN = 0;\n                    while(chunkN < chunkTotal){\n                        const chunk = chunks[chunkN];\n                        if (chan.bufferedAmount > chan.bufferedAmountLowThreshold) await new Promise((res)=>{\n                            const next = ()=>{\n                                chan.removeEventListener($4dd9fb32b9ed9581$var$buffLowEvent, next);\n                                res();\n                            };\n                            chan.addEventListener($4dd9fb32b9ed9581$var$buffLowEvent, next);\n                        });\n                        if (!peerMap[id]) break;\n                        peer.send(chunk);\n                        chunkN++;\n                        if (onProgress) onProgress(chunk[$4dd9fb32b9ed9581$var$progressIndex] / $4dd9fb32b9ed9581$var$oneByteMax, id, meta);\n                    }\n                }));\n            }\n        };\n        return [\n            actions[type].send,\n            actions[type].setOnComplete,\n            actions[type].setOnProgress\n        ];\n    };\n    const handleData = (id, data)=>{\n        const buffer = new Uint8Array(data);\n        const type = (0, $42a97e6b757c21d9$export$c97600adfa527f5b)(buffer.subarray($4dd9fb32b9ed9581$var$typeIndex, $4dd9fb32b9ed9581$var$nonceIndex)).replaceAll(\"\\0\", \"\");\n        const [nonce] = buffer.subarray($4dd9fb32b9ed9581$var$nonceIndex, $4dd9fb32b9ed9581$var$tagIndex);\n        const [tag] = buffer.subarray($4dd9fb32b9ed9581$var$tagIndex, $4dd9fb32b9ed9581$var$progressIndex);\n        const [progress] = buffer.subarray($4dd9fb32b9ed9581$var$progressIndex, $4dd9fb32b9ed9581$var$payloadIndex);\n        const payload = buffer.subarray($4dd9fb32b9ed9581$var$payloadIndex);\n        const isLast = !!(tag & 1);\n        const isMeta = !!(tag & 2);\n        const isBinary = !!(tag & 4);\n        const isJson = !!(tag & 8);\n        if (!actions[type]) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(`received message with unregistered type (${type})`);\n        if (!pendingTransmissions[id]) pendingTransmissions[id] = {};\n        if (!pendingTransmissions[id][type]) pendingTransmissions[id][type] = {};\n        let target = pendingTransmissions[id][type][nonce];\n        if (!target) target = pendingTransmissions[id][type][nonce] = {\n            chunks: []\n        };\n        if (isMeta) target.meta = JSON.parse((0, $42a97e6b757c21d9$export$c97600adfa527f5b)(payload));\n        else target.chunks.push(payload);\n        actions[type].onProgress(progress / $4dd9fb32b9ed9581$var$oneByteMax, id, target.meta);\n        if (!isLast) return;\n        const full = new Uint8Array(target.chunks.reduce((a, c)=>a + c.byteLength, 0));\n        target.chunks.reduce((a, c)=>{\n            full.set(c, a);\n            return a + c.byteLength;\n        }, 0);\n        if (isBinary) actions[type].onComplete(full, id, target.meta);\n        else {\n            const text = (0, $42a97e6b757c21d9$export$c97600adfa527f5b)(full);\n            actions[type].onComplete(isJson ? JSON.parse(text) : text, id);\n        }\n        delete pendingTransmissions[id][type][nonce];\n    };\n    const [sendPing, getPing] = makeAction(\"__91n6__\");\n    const [sendPong, getPong] = makeAction(\"__90n6__\");\n    const [sendSignal, getSignal] = makeAction(\"__516n4L__\");\n    const [sendStreamMeta, getStreamMeta] = makeAction(\"__57r34m__\");\n    const [sendTrackMeta, getTrackMeta] = makeAction(\"__7r4ck__\");\n    let onPeerJoin = (0, $42a97e6b757c21d9$export$b50b6e108474309b);\n    let onPeerLeave = (0, $42a97e6b757c21d9$export$b50b6e108474309b);\n    let onPeerStream = (0, $42a97e6b757c21d9$export$b50b6e108474309b);\n    let onPeerTrack = (0, $42a97e6b757c21d9$export$b50b6e108474309b);\n    onPeer((peer, id)=>{\n        if (peerMap[id]) return;\n        const onData = handleData.bind(null, id);\n        peerMap[id] = peer;\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).signal, (sdp)=>sendSignal(sdp, id));\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).close, ()=>exitPeer(id));\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).data, onData);\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).stream, (stream)=>{\n            onPeerStream(stream, id, pendingStreamMetas[id]);\n            delete pendingStreamMetas[id];\n        });\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).track, (track, stream)=>{\n            onPeerTrack(track, stream, id, pendingTrackMetas[id]);\n            delete pendingTrackMetas[id];\n        });\n        peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).error, (e)=>{\n            if (e.code === \"ERR_DATA_CHANNEL\") return;\n            console.error(e);\n        });\n        onPeerJoin(id);\n        peer.__drainEarlyData(onData);\n    });\n    getPing((_, id)=>sendPong(\"\", id));\n    getPong((_, id)=>{\n        if (pendingPongs[id]) {\n            pendingPongs[id]();\n            delete pendingPongs[id];\n        }\n    });\n    getSignal((sdp, id)=>{\n        if (peerMap[id]) peerMap[id].signal(sdp);\n    });\n    getStreamMeta((meta, id)=>pendingStreamMetas[id] = meta);\n    getTrackMeta((meta, id)=>pendingTrackMetas[id] = meta);\n    return {\n        makeAction: makeAction,\n        ping: async (id)=>{\n            if (!id) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"ping() must be called with target peer ID\");\n            const start = Date.now();\n            sendPing(\"\", id);\n            await new Promise((res)=>pendingPongs[id] = res);\n            return Date.now() - start;\n        },\n        leave: ()=>{\n            (0, $42a97e6b757c21d9$export$3e9f948b41964866)(peerMap).forEach(([id, peer])=>{\n                peer.destroy();\n                delete peerMap[id];\n            });\n            onSelfLeave();\n        },\n        getPeers: ()=>(0, $42a97e6b757c21d9$export$5150077fc2e7c662)((0, $42a97e6b757c21d9$export$3e9f948b41964866)(peerMap).map(([id, peer])=>[\n                    id,\n                    peer._pc\n                ])),\n        addStream: (stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendStreamMeta(meta, id);\n                peer.addStream(stream);\n            }),\n        removeStream: (stream, targets)=>iterate(targets, (_, peer)=>peer.removeStream(stream)),\n        addTrack: (track, stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendTrackMeta(meta, id);\n                peer.addTrack(track, stream);\n            }),\n        removeTrack: (track, stream, targets)=>iterate(targets, (_, peer)=>peer.removeTrack(track, stream)),\n        replaceTrack: (oldTrack, newTrack, stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendTrackMeta(meta, id);\n                peer.replaceTrack(oldTrack, newTrack, stream);\n            }),\n        onPeerJoin: (f)=>onPeerJoin = f,\n        onPeerLeave: (f)=>onPeerLeave = f,\n        onPeerStream: (f)=>onPeerStream = f,\n        onPeerTrack: (f)=>onPeerTrack = f\n    };\n};\n\n\n\n\nconst $dd87bb707555415a$var$algo = \"AES-CBC\";\nconst $dd87bb707555415a$var$pack = (buff)=>btoa(String.fromCharCode.apply(null, new Uint8Array(buff)));\nconst $dd87bb707555415a$var$unpack = (packed)=>{\n    const str = atob(packed);\n    return new Uint8Array(str.length).map((_, i)=>str.charCodeAt(i)).buffer;\n};\nconst $dd87bb707555415a$export$ceb27d5ba53e5cf8 = async (secret, ns)=>crypto.subtle.importKey(\"raw\", await crypto.subtle.digest({\n        name: \"SHA-256\"\n    }, (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(`${secret}:${ns}`)), {\n        name: $dd87bb707555415a$var$algo\n    }, false, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\nconst $dd87bb707555415a$export$5b0f6292f11d1d18 = async (keyP, plaintext)=>{\n    const iv = crypto.getRandomValues(new Uint8Array(16));\n    return JSON.stringify({\n        c: $dd87bb707555415a$var$pack(await crypto.subtle.encrypt({\n            name: $dd87bb707555415a$var$algo,\n            iv: iv\n        }, await keyP, (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(plaintext))),\n        iv: [\n            ...iv\n        ]\n    });\n};\nconst $dd87bb707555415a$export$e85a0c9a1067c5d3 = async (keyP, raw)=>{\n    const { c: c, iv: iv } = JSON.parse(raw);\n    return (0, $42a97e6b757c21d9$export$c97600adfa527f5b)(await crypto.subtle.decrypt({\n        name: $dd87bb707555415a$var$algo,\n        iv: new Uint8Array(iv)\n    }, await keyP, $dd87bb707555415a$var$unpack(c)));\n};\n\n\nconst $1098bf72ad57e222$var$occupiedRooms = {};\nconst $1098bf72ad57e222$var$socketPromises = {};\nconst $1098bf72ad57e222$var$sockets = {};\nconst $1098bf72ad57e222$var$socketRetryTimeouts = {};\nconst $1098bf72ad57e222$var$socketListeners = {};\nconst $1098bf72ad57e222$var$hashLimit = 20;\nconst $1098bf72ad57e222$var$offerPoolSize = 10;\nconst $1098bf72ad57e222$var$defaultRedundancy = 3;\nconst $1098bf72ad57e222$var$defaultAnnounceSecs = 33;\nconst $1098bf72ad57e222$var$maxAnnounceSecs = 120;\nconst $1098bf72ad57e222$var$trackerRetrySecs = 4;\nconst $1098bf72ad57e222$var$trackerAction = \"announce\";\nconst $1098bf72ad57e222$var$defaultRelayUrls = [\n    \"wss://tracker.webtorrent.dev\",\n    \"wss://tracker.openwebtorrent.com\",\n    \"wss://tracker.files.fm:7073/announce\",\n    \"wss://tracker.btorrent.xyz\"\n];\nconst $1098bf72ad57e222$export$767472c72ffc2784 = (0, $42a97e6b757c21d9$export$9cc48d06fd3e6e94)($1098bf72ad57e222$var$occupiedRooms, (config, ns)=>{\n    if (config.trackerUrls || config.trackerRedundancy) throw (0, $42a97e6b757c21d9$export$5575a5c000f2af79)(\"trackerUrls/trackerRedundancy have been replaced by relayUrls/relayRedundancy\");\n    const connectedPeers = {};\n    const key = config.password && (0, $dd87bb707555415a$export$ceb27d5ba53e5cf8)(config.password, ns);\n    const relayUrls = (0, $42a97e6b757c21d9$export$37be945df5c81949)(config, $1098bf72ad57e222$var$defaultRelayUrls, $1098bf72ad57e222$var$defaultRedundancy);\n    const infoHashP = crypto.subtle.digest(\"SHA-1\", (0, $42a97e6b757c21d9$export$2589e87d78677b0d)(`${(0, $42a97e6b757c21d9$export$cc42576d343e0f6a)}:${config.appId}:${ns}`)).then((buffer)=>Array.from(new Uint8Array(buffer)).map((b)=>b.toString(36)).join(\"\").slice(0, $1098bf72ad57e222$var$hashLimit));\n    const makeOffers = (howMany)=>(0, $42a97e6b757c21d9$export$5150077fc2e7c662)(Array(howMany).fill().map(()=>{\n            const peer = (0, $42a97e6b757c21d9$export$faba228f15d9c316)(true, false, config.rtcConfig);\n            return [\n                (0, $42a97e6b757c21d9$export$87d45d9755ebb726)($1098bf72ad57e222$var$hashLimit),\n                {\n                    peer: peer,\n                    offerP: new Promise((res)=>peer.once((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).signal, res))\n                }\n            ];\n        }));\n    const onSocketMessage = async (socket, e)=>{\n        const infoHash = await infoHashP;\n        let val;\n        try {\n            val = JSON.parse(e.data);\n        } catch (e) {\n            console.error(`${(0, $42a97e6b757c21d9$export$cc42576d343e0f6a)}: received malformed SDP JSON`);\n            return;\n        }\n        if (val.info_hash !== infoHash || val.peer_id && val.peer_id === (0, $42a97e6b757c21d9$export$d01767fa86c38c2d)) return;\n        const errMsg = val[\"failure reason\"];\n        if (errMsg) {\n            console.warn(`${(0, $42a97e6b757c21d9$export$cc42576d343e0f6a)}: torrent tracker failure from ${socket.url} - ${errMsg}`);\n            return;\n        }\n        if (val.interval && val.interval > announceSecs && val.interval <= $1098bf72ad57e222$var$maxAnnounceSecs) {\n            clearInterval(announceInterval);\n            announceSecs = val.interval;\n            announceInterval = setInterval(announceAll, announceSecs * 1000);\n        }\n        if (val.offer && val.offer_id) {\n            if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) return;\n            handledOffers[val.offer_id] = true;\n            const peer = (0, $42a97e6b757c21d9$export$faba228f15d9c316)(false, false, config.rtcConfig);\n            peer.once((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).signal, async (answer)=>socket.send(JSON.stringify({\n                    answer: key ? {\n                        ...answer,\n                        sdp: await (0, $dd87bb707555415a$export$5b0f6292f11d1d18)(key, answer.sdp)\n                    } : answer,\n                    action: $1098bf72ad57e222$var$trackerAction,\n                    info_hash: infoHash,\n                    peer_id: (0, $42a97e6b757c21d9$export$d01767fa86c38c2d),\n                    to_peer_id: val.peer_id,\n                    offer_id: val.offer_id\n                })));\n            peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).connect, ()=>onConnect(peer, val.peer_id));\n            peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).close, ()=>onDisconnect(peer, val.peer_id, val.offer_id));\n            peer.signal(key ? {\n                ...val.offer,\n                sdp: await (0, $dd87bb707555415a$export$e85a0c9a1067c5d3)(key, val.offer.sdp)\n            } : val.offer);\n            return;\n        }\n        if (val.answer) {\n            if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) return;\n            const offer = offerPool[val.offer_id];\n            if (offer) {\n                const { peer: peer } = offer;\n                if (peer.destroyed) return;\n                handledOffers[val.offer_id] = true;\n                peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).connect, ()=>onConnect(peer, val.peer_id, val.offer_id));\n                peer.on((0, $42a97e6b757c21d9$export$4bf9923669ad6c63).close, ()=>onDisconnect(peer, val.peer_id, val.offer_id));\n                peer.signal(key ? {\n                    ...val.answer,\n                    sdp: await (0, $dd87bb707555415a$export$e85a0c9a1067c5d3)(key, val.answer.sdp)\n                } : val.answer);\n            }\n        }\n    };\n    const announce = async (socket, infoHash)=>socket.send(JSON.stringify({\n            action: $1098bf72ad57e222$var$trackerAction,\n            info_hash: infoHash,\n            numwant: $1098bf72ad57e222$var$offerPoolSize,\n            peer_id: (0, $42a97e6b757c21d9$export$d01767fa86c38c2d),\n            offers: await Promise.all((0, $42a97e6b757c21d9$export$3e9f948b41964866)(offerPool).map(async ([id, { offerP: offerP }])=>{\n                const offer = await offerP;\n                return {\n                    offer_id: id,\n                    offer: key ? {\n                        ...offer,\n                        sdp: await (0, $dd87bb707555415a$export$5b0f6292f11d1d18)(key, offer.sdp)\n                    } : offer\n                };\n            }))\n        }));\n    const makeSocket = (url, infoHash, forced)=>{\n        if (forced || !$1098bf72ad57e222$var$socketPromises[url]) {\n            $1098bf72ad57e222$var$socketListeners[url] = {\n                ...$1098bf72ad57e222$var$socketListeners[url],\n                [infoHash]: onSocketMessage\n            };\n            $1098bf72ad57e222$var$socketPromises[url] = new Promise((res)=>{\n                const socket = new WebSocket(url);\n                $1098bf72ad57e222$var$sockets[url] = socket;\n                socket.addEventListener(\"open\", ()=>{\n                    // Reset the retry timeout for this tracker\n                    $1098bf72ad57e222$var$socketRetryTimeouts[url] = $1098bf72ad57e222$var$trackerRetrySecs * 1000;\n                    res(socket);\n                });\n                socket.addEventListener(\"message\", (e)=>(0, $42a97e6b757c21d9$export$68c286be0e7e55b7)($1098bf72ad57e222$var$socketListeners[url]).forEach((f)=>f(socket, e)));\n                socket.addEventListener(\"close\", async ()=>{\n                    $1098bf72ad57e222$var$socketRetryTimeouts[url] = $1098bf72ad57e222$var$socketRetryTimeouts[url] ?? $1098bf72ad57e222$var$trackerRetrySecs * 1000;\n                    await (0, $42a97e6b757c21d9$export$e772c8ff12451969)($1098bf72ad57e222$var$socketRetryTimeouts[url]);\n                    $1098bf72ad57e222$var$socketRetryTimeouts[url] *= 2;\n                    makeSocket(url, infoHash, true);\n                });\n            });\n        } else $1098bf72ad57e222$var$socketListeners[url][infoHash] = onSocketMessage;\n        return $1098bf72ad57e222$var$socketPromises[url];\n    };\n    const announceAll = async ()=>{\n        const infoHash = await infoHashP;\n        if (offerPool) cleanPool();\n        offerPool = makeOffers($1098bf72ad57e222$var$offerPoolSize);\n        relayUrls.forEach(async (url)=>{\n            const socket = await makeSocket(url, infoHash);\n            if (socket.readyState === WebSocket.OPEN) announce(socket, infoHash);\n            else if (socket.readyState !== WebSocket.CONNECTING) announce(await makeSocket(url, infoHash, true), infoHash);\n        });\n    };\n    const cleanPool = ()=>{\n        (0, $42a97e6b757c21d9$export$3e9f948b41964866)(offerPool).forEach(([id, { peer: peer }])=>{\n            if (!handledOffers[id] && !connectedPeers[id]) peer.destroy();\n        });\n        handledOffers = {};\n    };\n    const onConnect = (peer, id, offerId)=>{\n        onPeerConnect(peer, id);\n        connectedPeers[id] = true;\n        if (offerId) connectedPeers[offerId] = true;\n    };\n    const onDisconnect = (peer, peerId, offerId)=>{\n        delete connectedPeers[peerId];\n        peer.destroy();\n        const isInOfferPool = offerId in offerPool;\n        if (isInOfferPool) {\n            delete offerPool[offerId];\n            offerPool = {\n                ...offerPool,\n                ...makeOffers(1)\n            };\n        }\n    };\n    let announceSecs = $1098bf72ad57e222$var$defaultAnnounceSecs;\n    let announceInterval = setInterval(announceAll, announceSecs * 1000);\n    let onPeerConnect = (0, $42a97e6b757c21d9$export$b50b6e108474309b);\n    let handledOffers = {};\n    let offerPool;\n    announceAll();\n    return (0, $4dd9fb32b9ed9581$export$2e2bcd8739ae039)((f)=>onPeerConnect = f, async ()=>{\n        const infoHash = await infoHashP;\n        relayUrls.forEach((url)=>delete $1098bf72ad57e222$var$socketListeners[url][infoHash]);\n        delete $1098bf72ad57e222$var$occupiedRooms[ns];\n        clearInterval(announceInterval);\n        cleanPool();\n    });\n});\nconst $1098bf72ad57e222$export$21c289fa8cb92650 = ()=>({\n        ...$1098bf72ad57e222$var$sockets\n    });\n\n\n\n\nlet $dad545c909cfec2d$var$room, $dad545c909cfec2d$var$sendPic, $dad545c909cfec2d$var$getPic, $dad545c909cfec2d$var$sendCameraSettings, $dad545c909cfec2d$var$getCameraSettings, $dad545c909cfec2d$var$setZoom, $dad545c909cfec2d$var$getZoom, $dad545c909cfec2d$var$takePictureEvent, $dad545c909cfec2d$var$getTakePictureEvent;\nconst $dad545c909cfec2d$var$settings = {\n    roomId: null,\n    isCamera: false\n};\nfunction $dad545c909cfec2d$var$serialize(data) {\n    return encodeURIComponent(JSON.stringify(data)); // use something better\n}\n// helper function to turn a string back into an object\n// note: this is dumb and easy and not a good idea, just an example\nfunction $dad545c909cfec2d$var$deserialize(string) {\n    console.log(\"s\", string);\n    try {\n        return JSON.parse(decodeURIComponent(string)); // use something better\n    } catch (err) {\n        // lol the URL was shit probably\n        console.error(\"derp!\", err);\n        return undefined;\n    }\n}\n// every time the user does something, save the new state to the URL\nfunction $dad545c909cfec2d$var$save_new_state() {\n    // a temp data object to serialize\n    // serialize the data and save behind the url's #\n    window.location.hash = $dad545c909cfec2d$var$serialize($dad545c909cfec2d$var$settings);\n// show the current url in a readonly text field\n}\n// every time the page loads, see if some state came with it\nasync function $dad545c909cfec2d$var$load_state() {\n    $dad545c909cfec2d$var$room && $dad545c909cfec2d$var$room.leave();\n    $dad545c909cfec2d$var$room = null;\n    // will hold data if there is any\n    var data;\n    // get the current url hash (behind the #)\n    var url_hash = window.location.hash.substring(1);\n    console.log(\"hash on page load is\", url_hash); // debug in dev\n    // check for and apply state if any is present\n    if (url_hash !== undefined && url_hash !== \"\") {\n        console.log(\"whoa\"); // we found shit\n        // try turning the hash string into data\n        data = $dad545c909cfec2d$var$deserialize(url_hash);\n        console.log(\"got data:\", data);\n        if (data === undefined) return; // nope, nothing here\n        // do we see what we'd expect?\n        if (data.roomId !== undefined) {\n            $dad545c909cfec2d$var$settings.roomId = data.roomId;\n            $dad545c909cfec2d$var$roomIdInput.value = $dad545c909cfec2d$var$settings.roomId;\n            $dad545c909cfec2d$var$room = (0, $1098bf72ad57e222$export$767472c72ffc2784)({\n                appId: \"lolcat\"\n            }, roomId);\n            [$dad545c909cfec2d$var$sendPic, $dad545c909cfec2d$var$getPic] = $dad545c909cfec2d$var$room.makeAction(\"pic\");\n            [$dad545c909cfec2d$var$setZoom, $dad545c909cfec2d$var$getZoom] = $dad545c909cfec2d$var$room.makeAction(\"zoom\");\n            [$dad545c909cfec2d$var$takePictureEvent, $dad545c909cfec2d$var$getTakePictureEvent] = $dad545c909cfec2d$var$room.makeAction(\"takepic\");\n            [$dad545c909cfec2d$var$sendCameraSettings, $dad545c909cfec2d$var$getCameraSettings] = $dad545c909cfec2d$var$room.makeAction(\"settings\");\n            console.log($dad545c909cfec2d$var$room);\n        }\n        if (data.isCamera !== undefined) {\n            $dad545c909cfec2d$var$settings.isCamera = data.isCamera;\n            $dad545c909cfec2d$var$isCameraInput.checked = $dad545c909cfec2d$var$settings.isCamera;\n        }\n        if ($dad545c909cfec2d$var$settings.isCamera) navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: true\n        }).then((selfStream)=>{\n            const [track] = selfStream.getVideoTracks();\n            const capabilities = track.getCapabilities();\n            const settings = track.getSettings();\n            if (!(\"zoom\" in settings)) ;\n            else {\n                $dad545c909cfec2d$var$sendCameraSettings({\n                    min: capabilities.zoom.min,\n                    max: capabilities.zoom.max,\n                    step: capabilities.zoom.step,\n                    value: settings.zoom\n                });\n                $dad545c909cfec2d$var$getZoom((data, peerId)=>{\n                    console.log(\"got zoom level\", data);\n                    track.applyConstraints({\n                        advanced: [\n                            {\n                                zoom: data.zoomLevel\n                            }\n                        ]\n                    });\n                });\n            }\n            imageCapture = new ImageCapture(track);\n            $dad545c909cfec2d$var$getTakePictureEvent(()=>{\n                imageCapture.takePhoto().then((blob)=>{\n                    $dad545c909cfec2d$var$sendPic(blob);\n                }).catch(error);\n            });\n            $dad545c909cfec2d$var$room.addStream(selfStream);\n            $dad545c909cfec2d$var$room.onPeerJoin((peerId)=>$dad545c909cfec2d$var$room.addStream(selfStream, peerId));\n        });\n        else {\n            $dad545c909cfec2d$var$getCameraSettings((data, peerId)=>{\n                $dad545c909cfec2d$var$zoomInput.min = data.min;\n                $dad545c909cfec2d$var$zoomInput.max = data.max;\n                $dad545c909cfec2d$var$zoomInput.step = data.step;\n                $dad545c909cfec2d$var$zoomInput.value = data.value;\n            });\n            $dad545c909cfec2d$var$getPic((data, peerID)=>{\n                const fileUrl = window.URL.createObjectURL(new Blob([\n                    data\n                ]));\n                const anchorElement = document.createElement(\"a\");\n                anchorElement.href = fileUrl;\n                anchorElement.download = \"img.jpg\";\n                anchorElement.style.display = \"none\";\n                document.body.appendChild(anchorElement);\n                anchorElement.click();\n                anchorElement.remove();\n                window.URL.revokeObjectURL(fileUrl);\n            });\n            $dad545c909cfec2d$var$room.onPeerStream((stream, peerId)=>{\n                console.log(\"got video from peer:\", peerId);\n                $dad545c909cfec2d$var$video.srcObject = stream;\n                $dad545c909cfec2d$var$video.addEventListener(\"loadedmetadata\", ()=>{\n                    $dad545c909cfec2d$var$video.play();\n                });\n            });\n        }\n    }\n// update the url text field for dummies\n}\nconst $dad545c909cfec2d$var$takePicture = ()=>{\n    console.log(\"take picture\");\n    $dad545c909cfec2d$var$takePictureEvent({});\n};\nconst $dad545c909cfec2d$var$changeZoom = (e)=>{\n    var zoomLevel = e.target.value;\n    console.log(\"change zoom\", zoomLevel);\n    $dad545c909cfec2d$var$setZoom({\n        zoomLevel: zoomLevel\n    });\n};\nvar $dad545c909cfec2d$var$form = document.getElementById(\"form\");\nvar $dad545c909cfec2d$var$zoomInput = document.getElementById(\"zoom\");\nvar $dad545c909cfec2d$var$shootInput = document.getElementById(\"shoot\");\n$dad545c909cfec2d$var$zoomInput.onchange = $dad545c909cfec2d$var$changeZoom;\n$dad545c909cfec2d$var$shootInput.onclick = $dad545c909cfec2d$var$takePicture;\nvar $dad545c909cfec2d$var$roomIdInput = document.getElementById(\"roomId\");\nvar $dad545c909cfec2d$var$isCameraInput = document.getElementById(\"isCamera\");\nconst $dad545c909cfec2d$var$video = document.getElementById(\"camera\");\n$dad545c909cfec2d$var$form.onsubmit = function(event) {\n    event.preventDefault();\n    var formdata = new FormData($dad545c909cfec2d$var$form);\n    var data = Object.fromEntries(formdata);\n    $dad545c909cfec2d$var$settings.roomId = data.roomId;\n    $dad545c909cfec2d$var$settings.isCamera = data.isCamera ? true : false;\n    console.log($dad545c909cfec2d$var$settings, data);\n    $dad545c909cfec2d$var$save_new_state();\n    location.reload();\n    return false;\n};\n$dad545c909cfec2d$var$load_state();\n\n\n//# sourceMappingURL=index.44cdc2bf.js.map\n","import { joinRoom } from \"trystero\";\n\nlet room,\n  sendPic,\n  getPic,\n  sendCameraSettings,\n  getCameraSettings,\n  setZoom,\n  getZoom,\n  takePictureEvent,\n  getTakePictureEvent;\n\nconst settings = {\n  roomId: null,\n  isCamera: false,\n};\n\nfunction serialize(data) {\n  return encodeURIComponent(JSON.stringify(data)); // use something better\n}\n\n// helper function to turn a string back into an object\n// note: this is dumb and easy and not a good idea, just an example\nfunction deserialize(string) {\n  console.log(\"s\", string);\n  try {\n    return JSON.parse(decodeURIComponent(string)); // use something better\n  } catch (err) {\n    // lol the URL was shit probably\n    console.error(\"derp!\", err);\n    return undefined;\n  }\n}\n\n// every time the user does something, save the new state to the URL\nfunction save_new_state() {\n  // a temp data object to serialize\n  // serialize the data and save behind the url's #\n  window.location.hash = serialize(settings);\n  // show the current url in a readonly text field\n}\n\n// every time the page loads, see if some state came with it\nasync function load_state() {\n  room ? room.leave() : null;\n  room = null;\n\n  // will hold data if there is any\n  var data;\n  // get the current url hash (behind the #)\n  var url_hash = window.location.hash.substring(1);\n  console.log(\"hash on page load is\", url_hash); // debug in dev\n  // check for and apply state if any is present\n  if (url_hash !== undefined && url_hash !== \"\") {\n    console.log(\"whoa\"); // we found shit\n    // try turning the hash string into data\n    data = deserialize(url_hash);\n    console.log(\"got data:\", data);\n    if (data === undefined) {\n      return; // nope, nothing here\n    }\n    // do we see what we'd expect?\n    if (data.roomId !== undefined) {\n      settings.roomId = data.roomId;\n      roomIdInput.value = settings.roomId;\n      room = joinRoom({ appId: \"lolcat\" }, roomId);\n      [sendPic, getPic] = room.makeAction(\"pic\");\n      [setZoom, getZoom] = room.makeAction(\"zoom\");\n      [takePictureEvent, getTakePictureEvent] = room.makeAction(\"takepic\");\n      [sendCameraSettings, getCameraSettings] = room.makeAction(\"settings\");\n      console.log(room);\n    }\n    if (data.isCamera !== undefined) {\n      settings.isCamera = data.isCamera;\n      isCameraInput.checked = settings.isCamera;\n    }\n    if (settings.isCamera) {\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: true,\n        })\n        .then((selfStream) => {\n          const [track] = selfStream.getVideoTracks();\n          const capabilities = track.getCapabilities();\n          const settings = track.getSettings();\n          if (!(\"zoom\" in settings)) {\n          } else {\n            sendCameraSettings({\n              min: capabilities.zoom.min,\n              max: capabilities.zoom.max,\n              step: capabilities.zoom.step,\n              value: settings.zoom,\n            });\n            getZoom((data, peerId) => {\n              console.log(\"got zoom level\", data);\n              track.applyConstraints({ advanced: [{ zoom: data.zoomLevel }] });\n            });\n          }\n          imageCapture = new ImageCapture(track);\n\n          getTakePictureEvent(() => {\n            imageCapture\n              .takePhoto()\n              .then((blob) => {\n                sendPic(blob);\n              })\n              .catch(error);\n          });\n\n          room.addStream(selfStream);\n          room.onPeerJoin((peerId) => room.addStream(selfStream, peerId));\n        });\n    } else {\n        getCameraSettings((data, peerId)=>{\n            zoomInput.min = data.min\n            zoomInput.max=data.max\n            zoomInput.step = data.step\n            zoomInput.value = data.value\n        })\n      getPic((data, peerID) => {\n        const fileUrl = window.URL.createObjectURL(new Blob([data]));\n        const anchorElement = document.createElement(\"a\");\n\n        anchorElement.href = fileUrl;\n        anchorElement.download = \"img.jpg\";\n        anchorElement.style.display = \"none\";\n\n        document.body.appendChild(anchorElement);\n\n        anchorElement.click();\n        anchorElement.remove();\n\n        window.URL.revokeObjectURL(fileUrl);\n      });\n      room.onPeerStream((stream, peerId) => {\n        console.log(\"got video from peer:\", peerId);\n\n        video.srcObject = stream;\n        video.addEventListener(\"loadedmetadata\", () => {\n          video.play();\n        });\n      });\n    }\n  }\n  // update the url text field for dummies\n}\n\nconst takePicture = () => {\n  console.log(\"take picture\");\n  takePictureEvent({})\n};\nconst changeZoom = (e) => {\n  var zoomLevel = e.target.value;\n\n  console.log(\"change zoom\", zoomLevel);\n  setZoom({ zoomLevel: zoomLevel });\n};\nvar form = document.getElementById(\"form\");\nvar zoomInput = document.getElementById(\"zoom\");\nvar shootInput = document.getElementById(\"shoot\");\nzoomInput.onchange = changeZoom;\nshootInput.onclick = takePicture;\n\nvar roomIdInput = document.getElementById(\"roomId\");\nvar isCameraInput = document.getElementById(\"isCamera\");\nconst video = document.getElementById(\"camera\");\n\nform.onsubmit = function (event) {\n  event.preventDefault();\n  var formdata = new FormData(form);\n  var data = Object.fromEntries(formdata);\n  settings.roomId = data.roomId;\n  settings.isCamera = data.isCamera ? true : false;\n  console.log(settings, data);\n  save_new_state();\n  location.reload();\n\n  return false;\n};\n\nload_state();\n","export {getRelaySockets, joinRoom, selfId} from './torrent.js'\n","import room from './room.js'\nimport {\n  encodeBytes,\n  entries,\n  events,\n  fromEntries,\n  genId,\n  getRelays,\n  initGuard,\n  initPeer,\n  libName,\n  mkErr,\n  noOp,\n  selfId,\n  sleep,\n  values\n} from './utils.js'\nimport {decrypt, encrypt, genKey} from './crypto.js'\n\nconst occupiedRooms = {}\nconst socketPromises = {}\nconst sockets = {}\nconst socketRetryTimeouts = {}\nconst socketListeners = {}\nconst hashLimit = 20\nconst offerPoolSize = 10\nconst defaultRedundancy = 3\nconst defaultAnnounceSecs = 33\nconst maxAnnounceSecs = 120\nconst trackerRetrySecs = 4\nconst trackerAction = 'announce'\nconst defaultRelayUrls = [\n  'wss://tracker.webtorrent.dev',\n  'wss://tracker.openwebtorrent.com',\n  'wss://tracker.files.fm:7073/announce',\n  'wss://tracker.btorrent.xyz'\n]\n\nexport const joinRoom = initGuard(occupiedRooms, (config, ns) => {\n  if (config.trackerUrls || config.trackerRedundancy) {\n    throw mkErr(\n      'trackerUrls/trackerRedundancy have been replaced by relayUrls/relayRedundancy'\n    )\n  }\n\n  const connectedPeers = {}\n  const key = config.password && genKey(config.password, ns)\n  const relayUrls = getRelays(config, defaultRelayUrls, defaultRedundancy)\n\n  const infoHashP = crypto.subtle\n    .digest('SHA-1', encodeBytes(`${libName}:${config.appId}:${ns}`))\n    .then(buffer =>\n      Array.from(new Uint8Array(buffer))\n        .map(b => b.toString(36))\n        .join('')\n        .slice(0, hashLimit)\n    )\n\n  const makeOffers = howMany =>\n    fromEntries(\n      Array(howMany)\n        .fill()\n        .map(() => {\n          const peer = initPeer(true, false, config.rtcConfig)\n\n          return [\n            genId(hashLimit),\n            {peer, offerP: new Promise(res => peer.once(events.signal, res))}\n          ]\n        })\n    )\n\n  const onSocketMessage = async (socket, e) => {\n    const infoHash = await infoHashP\n    let val\n\n    try {\n      val = JSON.parse(e.data)\n    } catch (e) {\n      console.error(`${libName}: received malformed SDP JSON`)\n      return\n    }\n\n    if (val.info_hash !== infoHash || (val.peer_id && val.peer_id === selfId)) {\n      return\n    }\n\n    const errMsg = val['failure reason']\n\n    if (errMsg) {\n      console.warn(\n        `${libName}: torrent tracker failure from ${socket.url} - ${errMsg}`\n      )\n      return\n    }\n\n    if (\n      val.interval &&\n      val.interval > announceSecs &&\n      val.interval <= maxAnnounceSecs\n    ) {\n      clearInterval(announceInterval)\n      announceSecs = val.interval\n      announceInterval = setInterval(announceAll, announceSecs * 1000)\n    }\n\n    if (val.offer && val.offer_id) {\n      if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) {\n        return\n      }\n\n      handledOffers[val.offer_id] = true\n\n      const peer = initPeer(false, false, config.rtcConfig)\n\n      peer.once(events.signal, async answer =>\n        socket.send(\n          JSON.stringify({\n            answer: key\n              ? {...answer, sdp: await encrypt(key, answer.sdp)}\n              : answer,\n            action: trackerAction,\n            info_hash: infoHash,\n            peer_id: selfId,\n            to_peer_id: val.peer_id,\n            offer_id: val.offer_id\n          })\n        )\n      )\n      peer.on(events.connect, () => onConnect(peer, val.peer_id))\n      peer.on(events.close, () => onDisconnect(peer, val.peer_id, val.offer_id))\n      peer.signal(\n        key ? {...val.offer, sdp: await decrypt(key, val.offer.sdp)} : val.offer\n      )\n\n      return\n    }\n\n    if (val.answer) {\n      if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) {\n        return\n      }\n\n      const offer = offerPool[val.offer_id]\n\n      if (offer) {\n        const {peer} = offer\n\n        if (peer.destroyed) {\n          return\n        }\n\n        handledOffers[val.offer_id] = true\n        peer.on(events.connect, () =>\n          onConnect(peer, val.peer_id, val.offer_id)\n        )\n        peer.on(events.close, () =>\n          onDisconnect(peer, val.peer_id, val.offer_id)\n        )\n        peer.signal(\n          key\n            ? {...val.answer, sdp: await decrypt(key, val.answer.sdp)}\n            : val.answer\n        )\n      }\n    }\n  }\n\n  const announce = async (socket, infoHash) =>\n    socket.send(\n      JSON.stringify({\n        action: trackerAction,\n        info_hash: infoHash,\n        numwant: offerPoolSize,\n        peer_id: selfId,\n        offers: await Promise.all(\n          entries(offerPool).map(async ([id, {offerP}]) => {\n            const offer = await offerP\n\n            return {\n              offer_id: id,\n              offer: key\n                ? {...offer, sdp: await encrypt(key, offer.sdp)}\n                : offer\n            }\n          })\n        )\n      })\n    )\n\n  const makeSocket = (url, infoHash, forced) => {\n    if (forced || !socketPromises[url]) {\n      socketListeners[url] = {\n        ...socketListeners[url],\n        [infoHash]: onSocketMessage\n      }\n      socketPromises[url] = new Promise(res => {\n        const socket = new WebSocket(url)\n        sockets[url] = socket\n\n        socket.addEventListener('open', () => {\n          // Reset the retry timeout for this tracker\n          socketRetryTimeouts[url] = trackerRetrySecs * 1000\n          res(socket)\n        })\n\n        socket.addEventListener('message', e =>\n          values(socketListeners[url]).forEach(f => f(socket, e))\n        )\n\n        socket.addEventListener('close', async () => {\n          socketRetryTimeouts[url] =\n            socketRetryTimeouts[url] ?? trackerRetrySecs * 1000\n\n          await sleep(socketRetryTimeouts[url])\n          socketRetryTimeouts[url] *= 2\n\n          makeSocket(url, infoHash, true)\n        })\n      })\n    } else {\n      socketListeners[url][infoHash] = onSocketMessage\n    }\n\n    return socketPromises[url]\n  }\n\n  const announceAll = async () => {\n    const infoHash = await infoHashP\n\n    if (offerPool) {\n      cleanPool()\n    }\n\n    offerPool = makeOffers(offerPoolSize)\n\n    relayUrls.forEach(async url => {\n      const socket = await makeSocket(url, infoHash)\n\n      if (socket.readyState === WebSocket.OPEN) {\n        announce(socket, infoHash)\n      } else if (socket.readyState !== WebSocket.CONNECTING) {\n        announce(await makeSocket(url, infoHash, true), infoHash)\n      }\n    })\n  }\n\n  const cleanPool = () => {\n    entries(offerPool).forEach(([id, {peer}]) => {\n      if (!handledOffers[id] && !connectedPeers[id]) {\n        peer.destroy()\n      }\n    })\n\n    handledOffers = {}\n  }\n\n  const onConnect = (peer, id, offerId) => {\n    onPeerConnect(peer, id)\n    connectedPeers[id] = true\n\n    if (offerId) {\n      connectedPeers[offerId] = true\n    }\n  }\n\n  const onDisconnect = (peer, peerId, offerId) => {\n    delete connectedPeers[peerId]\n    peer.destroy()\n\n    const isInOfferPool = offerId in offerPool\n\n    if (isInOfferPool) {\n      delete offerPool[offerId]\n      offerPool = {...offerPool, ...makeOffers(1)}\n    }\n  }\n\n  let announceSecs = defaultAnnounceSecs\n  let announceInterval = setInterval(announceAll, announceSecs * 1000)\n  let onPeerConnect = noOp\n  let handledOffers = {}\n  let offerPool\n\n  announceAll()\n\n  return room(\n    f => (onPeerConnect = f),\n    async () => {\n      const infoHash = await infoHashP\n\n      relayUrls.forEach(url => delete socketListeners[url][infoHash])\n      delete occupiedRooms[ns]\n      clearInterval(announceInterval)\n      cleanPool()\n    }\n  )\n})\n\nexport const getRelaySockets = () => ({...sockets})\n\nexport {selfId} from './utils.js'\n","import {\n  decodeBytes,\n  encodeBytes,\n  entries,\n  events,\n  fromEntries,\n  keys,\n  libName,\n  mkErr,\n  noOp\n} from './utils.js'\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array)\nconst typeByteLimit = 12\nconst typeIndex = 0\nconst nonceIndex = typeIndex + typeByteLimit\nconst tagIndex = nonceIndex + 1\nconst progressIndex = tagIndex + 1\nconst payloadIndex = progressIndex + 1\nconst chunkSize = 16 * 2 ** 10 - payloadIndex\nconst oneByteMax = 0xff\nconst buffLowEvent = 'bufferedamountlow'\n\nexport default (onPeer, onSelfLeave) => {\n  const peerMap = {}\n  const actions = {}\n  const pendingTransmissions = {}\n  const pendingPongs = {}\n  const pendingStreamMetas = {}\n  const pendingTrackMetas = {}\n\n  const iterate = (targets, f) =>\n    (targets\n      ? Array.isArray(targets)\n        ? targets\n        : [targets]\n      : keys(peerMap)\n    ).flatMap(id => {\n      const peer = peerMap[id]\n\n      if (!peer) {\n        console.warn(`${libName}: no peer with id ${id} found`)\n        return []\n      }\n\n      return f(id, peer)\n    })\n\n  const exitPeer = id => {\n    if (!peerMap[id]) {\n      return\n    }\n\n    delete peerMap[id]\n    delete pendingTransmissions[id]\n    delete pendingPongs[id]\n    onPeerLeave(id)\n  }\n\n  const makeAction = type => {\n    if (actions[type]) {\n      return [\n        actions[type].send,\n        actions[type].setOnComplete,\n        actions[type].setOnProgress\n      ]\n    }\n\n    if (!type) {\n      throw mkErr('action type argument is required')\n    }\n\n    const typeBytes = encodeBytes(type)\n\n    if (typeBytes.byteLength > typeByteLimit) {\n      throw mkErr(\n        `action type string \"${type}\" (${typeBytes.byteLength}b) exceeds ` +\n          `byte limit (${typeByteLimit}). Hint: choose a shorter name.`\n      )\n    }\n\n    const typeBytesPadded = new Uint8Array(typeByteLimit)\n    typeBytesPadded.set(typeBytes)\n\n    let nonce = 0\n\n    actions[type] = {\n      onComplete: noOp,\n      onProgress: noOp,\n\n      setOnComplete: f => (actions[type] = {...actions[type], onComplete: f}),\n\n      setOnProgress: f => (actions[type] = {...actions[type], onProgress: f}),\n\n      send: async (data, targets, meta, onProgress) => {\n        if (meta && typeof meta !== 'object') {\n          throw mkErr('action meta argument must be an object')\n        }\n\n        if (data === undefined) {\n          throw mkErr('action data cannot be undefined')\n        }\n\n        const isJson = typeof data !== 'string'\n        const isBlob = data instanceof Blob\n        const isBinary =\n          isBlob || data instanceof ArrayBuffer || data instanceof TypedArray\n\n        if (meta && !isBinary) {\n          throw mkErr('action meta argument can only be used with binary data')\n        }\n\n        const buffer = isBinary\n          ? new Uint8Array(isBlob ? await data.arrayBuffer() : data)\n          : encodeBytes(isJson ? JSON.stringify(data) : data)\n\n        const metaEncoded = meta ? encodeBytes(JSON.stringify(meta)) : null\n\n        const chunkTotal =\n          Math.ceil(buffer.byteLength / chunkSize) + (meta ? 1 : 0) || 1\n\n        const chunks = Array(chunkTotal)\n          .fill()\n          .map((_, i) => {\n            const isLast = i === chunkTotal - 1\n            const isMeta = meta && i === 0\n            const chunk = new Uint8Array(\n              payloadIndex +\n                (isMeta\n                  ? metaEncoded.byteLength\n                  : isLast\n                    ? buffer.byteLength -\n                      chunkSize * (chunkTotal - (meta ? 2 : 1))\n                    : chunkSize)\n            )\n\n            chunk.set(typeBytesPadded)\n            chunk.set([nonce], nonceIndex)\n            chunk.set(\n              [isLast | (isMeta << 1) | (isBinary << 2) | (isJson << 3)],\n              tagIndex\n            )\n            chunk.set(\n              [Math.round(((i + 1) / chunkTotal) * oneByteMax)],\n              progressIndex\n            )\n            chunk.set(\n              meta\n                ? isMeta\n                  ? metaEncoded\n                  : buffer.subarray((i - 1) * chunkSize, i * chunkSize)\n                : buffer.subarray(i * chunkSize, (i + 1) * chunkSize),\n              payloadIndex\n            )\n\n            return chunk\n          })\n\n        nonce = (nonce + 1) & oneByteMax\n\n        return Promise.all(\n          iterate(targets, async (id, peer) => {\n            const chan = peer._channel\n            let chunkN = 0\n\n            while (chunkN < chunkTotal) {\n              const chunk = chunks[chunkN]\n\n              if (chan.bufferedAmount > chan.bufferedAmountLowThreshold) {\n                await new Promise(res => {\n                  const next = () => {\n                    chan.removeEventListener(buffLowEvent, next)\n                    res()\n                  }\n\n                  chan.addEventListener(buffLowEvent, next)\n                })\n              }\n\n              if (!peerMap[id]) {\n                break\n              }\n\n              peer.send(chunk)\n              chunkN++\n\n              if (onProgress) {\n                onProgress(chunk[progressIndex] / oneByteMax, id, meta)\n              }\n            }\n          })\n        )\n      }\n    }\n\n    return [\n      actions[type].send,\n      actions[type].setOnComplete,\n      actions[type].setOnProgress\n    ]\n  }\n\n  const handleData = (id, data) => {\n    const buffer = new Uint8Array(data)\n    const type = decodeBytes(buffer.subarray(typeIndex, nonceIndex)).replaceAll(\n      '\\x00',\n      ''\n    )\n    const [nonce] = buffer.subarray(nonceIndex, tagIndex)\n    const [tag] = buffer.subarray(tagIndex, progressIndex)\n    const [progress] = buffer.subarray(progressIndex, payloadIndex)\n    const payload = buffer.subarray(payloadIndex)\n    const isLast = !!(tag & 1)\n    const isMeta = !!(tag & (1 << 1))\n    const isBinary = !!(tag & (1 << 2))\n    const isJson = !!(tag & (1 << 3))\n\n    if (!actions[type]) {\n      throw mkErr(`received message with unregistered type (${type})`)\n    }\n\n    if (!pendingTransmissions[id]) {\n      pendingTransmissions[id] = {}\n    }\n\n    if (!pendingTransmissions[id][type]) {\n      pendingTransmissions[id][type] = {}\n    }\n\n    let target = pendingTransmissions[id][type][nonce]\n\n    if (!target) {\n      target = pendingTransmissions[id][type][nonce] = {chunks: []}\n    }\n\n    if (isMeta) {\n      target.meta = JSON.parse(decodeBytes(payload))\n    } else {\n      target.chunks.push(payload)\n    }\n\n    actions[type].onProgress(progress / oneByteMax, id, target.meta)\n\n    if (!isLast) {\n      return\n    }\n\n    const full = new Uint8Array(\n      target.chunks.reduce((a, c) => a + c.byteLength, 0)\n    )\n\n    target.chunks.reduce((a, c) => {\n      full.set(c, a)\n      return a + c.byteLength\n    }, 0)\n\n    if (isBinary) {\n      actions[type].onComplete(full, id, target.meta)\n    } else {\n      const text = decodeBytes(full)\n      actions[type].onComplete(isJson ? JSON.parse(text) : text, id)\n    }\n\n    delete pendingTransmissions[id][type][nonce]\n  }\n\n  const [sendPing, getPing] = makeAction('__91n6__')\n  const [sendPong, getPong] = makeAction('__90n6__')\n  const [sendSignal, getSignal] = makeAction('__516n4L__')\n  const [sendStreamMeta, getStreamMeta] = makeAction('__57r34m__')\n  const [sendTrackMeta, getTrackMeta] = makeAction('__7r4ck__')\n\n  let onPeerJoin = noOp\n  let onPeerLeave = noOp\n  let onPeerStream = noOp\n  let onPeerTrack = noOp\n\n  onPeer((peer, id) => {\n    if (peerMap[id]) {\n      return\n    }\n\n    const onData = handleData.bind(null, id)\n\n    peerMap[id] = peer\n\n    peer.on(events.signal, sdp => sendSignal(sdp, id))\n    peer.on(events.close, () => exitPeer(id))\n    peer.on(events.data, onData)\n\n    peer.on(events.stream, stream => {\n      onPeerStream(stream, id, pendingStreamMetas[id])\n      delete pendingStreamMetas[id]\n    })\n\n    peer.on(events.track, (track, stream) => {\n      onPeerTrack(track, stream, id, pendingTrackMetas[id])\n      delete pendingTrackMetas[id]\n    })\n\n    peer.on(events.error, e => {\n      if (e.code === 'ERR_DATA_CHANNEL') {\n        return\n      }\n      console.error(e)\n    })\n\n    onPeerJoin(id)\n    peer.__drainEarlyData(onData)\n  })\n\n  getPing((_, id) => sendPong('', id))\n\n  getPong((_, id) => {\n    if (pendingPongs[id]) {\n      pendingPongs[id]()\n      delete pendingPongs[id]\n    }\n  })\n\n  getSignal((sdp, id) => {\n    if (peerMap[id]) {\n      peerMap[id].signal(sdp)\n    }\n  })\n\n  getStreamMeta((meta, id) => (pendingStreamMetas[id] = meta))\n\n  getTrackMeta((meta, id) => (pendingTrackMetas[id] = meta))\n\n  return {\n    makeAction,\n\n    ping: async id => {\n      if (!id) {\n        throw mkErr('ping() must be called with target peer ID')\n      }\n\n      const start = Date.now()\n\n      sendPing('', id)\n      await new Promise(res => (pendingPongs[id] = res))\n      return Date.now() - start\n    },\n\n    leave: () => {\n      entries(peerMap).forEach(([id, peer]) => {\n        peer.destroy()\n        delete peerMap[id]\n      })\n      onSelfLeave()\n    },\n\n    getPeers: () =>\n      fromEntries(entries(peerMap).map(([id, peer]) => [id, peer._pc])),\n\n    addStream: (stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendStreamMeta(meta, id)\n        }\n\n        peer.addStream(stream)\n      }),\n\n    removeStream: (stream, targets) =>\n      iterate(targets, (_, peer) => peer.removeStream(stream)),\n\n    addTrack: (track, stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.addTrack(track, stream)\n      }),\n\n    removeTrack: (track, stream, targets) =>\n      iterate(targets, (_, peer) => peer.removeTrack(track, stream)),\n\n    replaceTrack: (oldTrack, newTrack, stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.replaceTrack(oldTrack, newTrack, stream)\n      }),\n\n    onPeerJoin: f => (onPeerJoin = f),\n\n    onPeerLeave: f => (onPeerLeave = f),\n\n    onPeerStream: f => (onPeerStream = f),\n\n    onPeerTrack: f => (onPeerTrack = f)\n  }\n}\n","import Peer from 'simple-peer-light'\n\nconst charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'\n\nexport const initPeer = (initiator, trickle, config) => {\n  const peer = new Peer({initiator, trickle, config})\n  const onData = data => peer.__earlyDataBuffer.push(data)\n\n  peer.on(events.data, onData)\n  peer.__earlyDataBuffer = []\n  peer.__drainEarlyData = f => {\n    peer.off(events.data, onData)\n    peer.__earlyDataBuffer.forEach(f)\n    delete peer.__earlyDataBuffer\n    delete peer.__drainEarlyData\n  }\n\n  return peer\n}\n\nexport const genId = n =>\n  Array(n)\n    .fill()\n    .map(() => charSet[Math.floor(Math.random() * charSet.length)])\n    .join('')\n\nexport const initGuard = (occupiedRooms, f) => (config, ns) => {\n  if (occupiedRooms[ns]) {\n    return occupiedRooms[ns]\n  }\n\n  if (!config) {\n    throw mkErr('requires a config map as the first argument')\n  }\n\n  if (!config.appId && !config.firebaseApp) {\n    throw mkErr('config map is missing appId field')\n  }\n\n  if (!ns) {\n    throw mkErr('namespace argument required')\n  }\n\n  return (occupiedRooms[ns] = f(config, ns))\n}\n\nexport const libName = 'Trystero'\n\nexport const selfId = genId(20)\n\nexport const {keys, values, entries, fromEntries} = Object\n\nexport const noOp = () => {}\n\nexport const mkErr = msg => new Error(`${libName}: ${msg}`)\n\nexport const encodeBytes = txt => new TextEncoder().encode(txt)\n\nexport const decodeBytes = buffer => new TextDecoder().decode(buffer)\n\nexport const toHex = buffer =>\n  buffer.reduce((a, c) => a + c.toString(16).padStart(2, '0'), '')\n\nexport const events = fromEntries(\n  ['close', 'connect', 'data', 'error', 'signal', 'stream', 'track'].map(k => [\n    k,\n    k\n  ])\n)\n\nexport const getRelays = (config, defaults, defaultN) =>\n  (config.relayUrls || defaults).slice(\n    0,\n    config.relayUrls\n      ? config.relayUrls.length\n      : config.relayRedundancy || defaultN\n  )\n\nexport const sleep = ms => new Promise(res => setTimeout(res, ms))\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\nfunction randombytes (size) {\n  const array = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    array[i] = (Math.random() * 256) | 0\n  }\n  return array\n}\n\nfunction getBrowserRTC () {\n  if (typeof globalThis === 'undefined') return null\n  const wrtc = {\n    RTCPeerConnection:\n      globalThis.RTCPeerConnection ||\n      globalThis.mozRTCPeerConnection ||\n      globalThis.webkitRTCPeerConnection,\n    RTCSessionDescription:\n      globalThis.RTCSessionDescription ||\n      globalThis.mozRTCSessionDescription ||\n      globalThis.webkitRTCSessionDescription,\n    RTCIceCandidate:\n      globalThis.RTCIceCandidate ||\n      globalThis.mozRTCIceCandidate ||\n      globalThis.webkitRTCIceCandidate\n  }\n  if (!wrtc.RTCPeerConnection) return null\n  return wrtc\n}\n\nfunction errCode (err, code) {\n  Object.defineProperty(err, 'code', {\n    value: code,\n    enumerable: true,\n    configurable: true\n  })\n  return err\n}\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n}\n\nfunction warn (message) {\n  console.warn(message)\n}\n\n/**\n * WebRTC peer connection.\n * @param {Object} opts\n */\nclass Peer {\n  constructor (opts = {}) {\n    this._map = new Map() // for event emitter\n\n    this._id = randombytes(4).toString('hex').slice(0, 7)\n    this._doDebug = opts.debug\n    this._debug('new peer %o', opts)\n\n    this.channelName = opts.initiator\n      ? opts.channelName || randombytes(20).toString('hex')\n      : null\n\n    this.initiator = opts.initiator || false\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\n    this.channelNegotiated = this.channelConfig.negotiated\n    this.config = Object.assign({}, Peer.config, opts.config)\n    this.offerOptions = opts.offerOptions || {}\n    this.answerOptions = opts.answerOptions || {}\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\n    this.allowHalfTrickle =\n      opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n    this.destroyed = false\n    this.destroying = false\n    this._connected = false\n\n    this.remoteAddress = undefined\n    this.remoteFamily = undefined\n    this.remotePort = undefined\n    this.localAddress = undefined\n    this.localFamily = undefined\n    this.localPort = undefined\n\n    this._wrtc =\n      opts.wrtc && typeof opts.wrtc === 'object' ? opts.wrtc : getBrowserRTC()\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw errCode(\n          new Error(\n            'No WebRTC support: Specify `opts.wrtc` option in this environment'\n          ),\n          'ERR_WEBRTC_SUPPORT'\n        )\n      } else {\n        throw errCode(\n          new Error('No WebRTC support: Not a supported browser'),\n          'ERR_WEBRTC_SUPPORT'\n        )\n      }\n    }\n\n    this._pcReady = false\n    this._channelReady = false\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n    this._channel = null\n    this._pendingCandidates = []\n\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\n    this._firstNegotiation = true\n    this._batchedNegotiation = false // batch synchronous negotiations\n    this._queuedNegotiation = false // is there a queued negotiation request?\n    this._sendersAwaitingStable = []\n    this._senderMap = new Map()\n    this._closingInterval = null\n\n    this._remoteTracks = []\n    this._remoteStreams = []\n\n    this._chunk = null\n    this._cb = null\n    this._interval = null\n\n    try {\n      this._pc = new this._wrtc.RTCPeerConnection(this.config)\n    } catch (err) {\n      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\n      return\n    }\n\n    // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange()\n    }\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange()\n    }\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event)\n    }\n\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n    if (typeof this._pc.peerIdentity === 'object') {\n      this._pc.peerIdentity.catch(err => {\n        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\n      })\n    }\n\n    // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n    if (this.initiator || this.channelNegotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(\n          this.channelName,\n          this.channelConfig\n        )\n      })\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event)\n      }\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream)\n      })\n    }\n    this._pc.ontrack = event => {\n      this._onTrack(event)\n    }\n\n    this._debug('initial negotiation')\n    this._needsNegotiation()\n  }\n\n  get bufferSize () {\n    return (this._channel && this._channel.bufferedAmount) || 0\n  }\n\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n  get connected () {\n    return this._connected && this._channel.readyState === 'open'\n  }\n\n  address () {\n    return {\n      port: this.localPort,\n      family: this.localFamily,\n      address: this.localAddress\n    }\n  }\n\n  signal (data) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data)\n      } catch (err) {\n        data = {}\n      }\n    }\n    this._debug('signal()')\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate')\n      this._needsNegotiation()\n    }\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver')\n      this.addTransceiver(\n        data.transceiverRequest.kind,\n        data.transceiverRequest.init\n      )\n    }\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate)\n      } else {\n        this._pendingCandidates.push(data.candidate)\n      }\n    }\n    if (data.sdp) {\n      this._pc\n        .setRemoteDescription(new this._wrtc.RTCSessionDescription(data))\n        .then(() => {\n          if (this.destroyed) return\n\n          this._pendingCandidates.forEach(candidate => {\n            this._addIceCandidate(candidate)\n          })\n          this._pendingCandidates = []\n\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n        })\n        .catch(err => {\n          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\n        })\n    }\n    if (\n      !data.sdp &&\n      !data.candidate &&\n      !data.renegotiate &&\n      !data.transceiverRequest\n    ) {\n      this.destroy(\n        errCode(\n          new Error('signal() called with invalid signal data'),\n          'ERR_SIGNALING'\n        )\n      )\n    }\n  }\n\n  _addIceCandidate (candidate) {\n    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n    this._pc.addIceCandidate(iceCandidateObj).catch(err => {\n      if (\n        !iceCandidateObj.address ||\n        iceCandidateObj.address.endsWith('.local')\n      ) {\n        warn('Ignoring unsupported ICE candidate.')\n      } else {\n        this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\n      }\n    })\n  }\n\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|string|Blob} chunk\n   */\n  send (chunk) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\n    this._channel.send(chunk)\n  }\n\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n  addTransceiver (kind, init) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTransceiver()')\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init)\n        this._needsNegotiation()\n      } catch (err) {\n        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\n      }\n    } else {\n      this.emit('signal', {\n        // request initiator to renegotiate\n        type: 'transceiverRequest',\n        transceiverRequest: { kind, init }\n      })\n    }\n  }\n\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n  addStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addStream()')\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream)\n    })\n  }\n\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  addTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('addTrack()')\n\n    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    let sender = submap.get(stream)\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream)\n      submap.set(stream, sender)\n      this._senderMap.set(track, submap)\n      this._needsNegotiation()\n    } else if (sender.removed) {\n      throw errCode(\n        new Error(\n          'Track has been removed. You should enable/disable tracks that you want to re-add.'\n        ),\n        'ERR_SENDER_REMOVED'\n      )\n    } else {\n      throw errCode(\n        new Error('Track has already been added to that stream.'),\n        'ERR_SENDER_ALREADY_ADDED'\n      )\n    }\n  }\n\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n  replaceTrack (oldTrack, newTrack, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('replaceTrack()')\n\n    const submap = this._senderMap.get(oldTrack)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(\n        new Error('Cannot replace track that was never added.'),\n        'ERR_TRACK_NOT_ADDED'\n      )\n    }\n    if (newTrack) this._senderMap.set(newTrack, submap)\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack)\n    } else {\n      this.destroy(\n        errCode(\n          new Error('replaceTrack is not supported in this browser'),\n          'ERR_UNSUPPORTED_REPLACETRACK'\n        )\n      )\n    }\n  }\n\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  removeTrack (track, stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSender()')\n\n    const submap = this._senderMap.get(track)\n    const sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw errCode(\n        new Error('Cannot remove track that was never added.'),\n        'ERR_TRACK_NOT_ADDED'\n      )\n    }\n    try {\n      sender.removed = true\n      this._pc.removeTrack(sender)\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n      } else {\n        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))\n      }\n    }\n    this._needsNegotiation()\n  }\n\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n  removeStream (stream) {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')\n    this._debug('removeSenders()')\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream)\n    })\n  }\n\n  _needsNegotiation () {\n    this._debug('_needsNegotiation')\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\n    this._batchedNegotiation = true\n    queueMicrotask(() => {\n      this._batchedNegotiation = false\n      if (this.initiator || !this._firstNegotiation) {\n        this._debug('starting batched negotiation')\n        this.negotiate()\n      } else {\n        this._debug('non-initiator initial negotiation request discarded')\n      }\n      this._firstNegotiation = false\n    })\n  }\n\n  negotiate () {\n    if (this.destroying) return\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\n\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('start negotiation')\n        setTimeout(() => {\n          // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer()\n        }, 0)\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('requesting negotiation from initiator')\n        this.emit('signal', {\n          // request initiator to renegotiate\n          type: 'renegotiate',\n          renegotiate: true\n        })\n      }\n    }\n    this._isNegotiating = true\n  }\n\n  destroy (err) {\n    if (this.destroyed || this.destroying) return\n    this.destroying = true\n\n    this._debug('destroying (error: %s)', err && (err.message || err))\n\n    queueMicrotask(() => {\n      // allow events concurrent with the call to _destroy() to fire (see #692)\n      this.destroyed = true\n      this.destroying = false\n\n      this._debug('destroy (error: %s)', err && (err.message || err))\n\n      this._connected = false\n      this._pcReady = false\n      this._channelReady = false\n      this._remoteTracks = null\n      this._remoteStreams = null\n      this._senderMap = null\n\n      clearInterval(this._closingInterval)\n      this._closingInterval = null\n\n      clearInterval(this._interval)\n      this._interval = null\n      this._chunk = null\n      this._cb = null\n\n      if (this._channel) {\n        try {\n          this._channel.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._channel.onmessage = null\n        this._channel.onopen = null\n        this._channel.onclose = null\n        this._channel.onerror = null\n      }\n      if (this._pc) {\n        try {\n          this._pc.close()\n        } catch (err) {}\n\n        // allow events concurrent with destruction to be handled\n        this._pc.oniceconnectionstatechange = null\n        this._pc.onicegatheringstatechange = null\n        this._pc.onsignalingstatechange = null\n        this._pc.onicecandidate = null\n        this._pc.ontrack = null\n        this._pc.ondatachannel = null\n      }\n      this._pc = null\n      this._channel = null\n\n      if (err) this.emit('error', err)\n      this.emit('close')\n    })\n  }\n\n  _setupData (event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(\n        errCode(\n          new Error('Data channel event is missing `channel` property'),\n          'ERR_DATA_CHANNEL'\n        )\n      )\n    }\n\n    this._channel = event.channel\n    this._channel.binaryType = 'arraybuffer'\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    this.channelName = this._channel.label\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event)\n    }\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow()\n    }\n    this._channel.onopen = () => {\n      this._onChannelOpen()\n    }\n    this._channel.onclose = () => {\n      this._onChannelClose()\n    }\n    this._channel.onerror = err => {\n      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n    }\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    let isClosing = false\n    this._closingInterval = setInterval(() => {\n      // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  _startIceCompleteTimeout () {\n    if (this.destroyed) return\n    if (this._iceCompleteTimer) return\n    this._debug('started iceComplete timeout')\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true\n        this._debug('iceComplete timeout completed')\n        this.emit('iceTimeout')\n        this.emit('_iceComplete')\n      }\n    }, this.iceCompleteTimeout)\n  }\n\n  _createOffer () {\n    if (this.destroyed) return\n\n    this._pc\n      .createOffer(this.offerOptions)\n      .then(offer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) { offer.sdp = filterTrickle(offer.sdp) }\n        offer.sdp = this.sdpTransform(offer.sdp)\n\n        const sendOffer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || offer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n        }\n\n        const onSuccess = () => {\n          this._debug('createOffer success')\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendOffer()\n          else this.once('_iceComplete', sendOffer) // wait for candidates\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(offer).then(onSuccess).catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))\n      })\n  }\n\n  _requestMissingTransceivers () {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (\n          !transceiver.mid &&\n          transceiver.sender.track &&\n          !transceiver.requested\n        ) {\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n          this.addTransceiver(transceiver.sender.track.kind)\n        }\n      })\n    }\n  }\n\n  _createAnswer () {\n    if (this.destroyed) return\n\n    this._pc\n      .createAnswer(this.answerOptions)\n      .then(answer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) { answer.sdp = filterTrickle(answer.sdp) }\n        answer.sdp = this.sdpTransform(answer.sdp)\n\n        const sendAnswer = () => {\n          if (this.destroyed) return\n          const signal = this._pc.localDescription || answer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n          if (!this.initiator) this._requestMissingTransceivers()\n        }\n\n        const onSuccess = () => {\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendAnswer()\n          else this.once('_iceComplete', sendAnswer)\n        }\n\n        const onError = err => {\n          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(answer).then(onSuccess).catch(onError)\n      })\n      .catch(err => {\n        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))\n      })\n  }\n\n  _onConnectionStateChange () {\n    if (this.destroyed) return\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(\n        errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE')\n      )\n    }\n  }\n\n  _onIceStateChange () {\n    if (this.destroyed) return\n    const iceConnectionState = this._pc.iceConnectionState\n    const iceGatheringState = this._pc.iceGatheringState\n\n    this._debug(\n      'iceStateChange (connection: %s) (gathering: %s)',\n      iceConnectionState,\n      iceGatheringState\n    )\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n    if (\n      iceConnectionState === 'connected' ||\n      iceConnectionState === 'completed'\n    ) {\n      this._pcReady = true\n      this._maybeReady()\n    }\n    if (iceConnectionState === 'failed') {\n      this.destroy(\n        errCode(\n          new Error('Ice connection failed.'),\n          'ERR_ICE_CONNECTION_FAILURE'\n        )\n      )\n    }\n    if (iceConnectionState === 'closed') {\n      this.destroy(\n        errCode(\n          new Error('Ice connection closed.'),\n          'ERR_ICE_CONNECTION_CLOSED'\n        )\n      )\n    }\n  }\n\n  getStats (cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value)\n        })\n      }\n      return report\n    }\n\n    // Promise-based getStats() (standard)\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats().then(\n        res => {\n          const reports = []\n          res.forEach(report => {\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        },\n        err => cb(err)\n      )\n\n      // Single-parameter callback-based getStats() (non-standard)\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(\n        res => {\n          // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n          if (this.destroyed) return\n\n          const reports = []\n          res.result().forEach(result => {\n            const report = {}\n            result.names().forEach(name => {\n              report[name] = result.stat(name)\n            })\n            report.id = result.id\n            report.type = result.type\n            report.timestamp = result.timestamp\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        },\n        err => cb(err)\n      )\n\n      // Unknown browser, skip getStats() since it's anyone's guess which style of\n      // getStats() they implement.\n    } else {\n      cb(null, [])\n    }\n  }\n\n  _maybeReady () {\n    this._debug(\n      'maybeReady pc %s channel %s',\n      this._pcReady,\n      this._channelReady\n    )\n    if (\n      this._connected ||\n      this._connecting ||\n      !this._pcReady ||\n      !this._channelReady\n    ) { return }\n\n    this._connecting = true\n\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n    const findCandidatePair = () => {\n      if (this.destroyed) return\n\n      this.getStats((err, items) => {\n        if (this.destroyed) return\n\n        // Treat getStats error as non-fatal. It's not essential.\n        if (err) items = []\n\n        const remoteCandidates = {}\n        const localCandidates = {}\n        const candidatePairs = {}\n        let foundSelectedCandidatePair = false\n\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (\n            item.type === 'remotecandidate' ||\n            item.type === 'remote-candidate'\n          ) {\n            remoteCandidates[item.id] = item\n          }\n          if (\n            item.type === 'localcandidate' ||\n            item.type === 'local-candidate'\n          ) {\n            localCandidates[item.id] = item\n          }\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item\n          }\n        })\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true\n\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address\n            this.localPort = Number(local.port)\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress\n            this.localPort = Number(local.portNumber)\n          } else if (\n            typeof selectedCandidatePair.googLocalAddress === 'string'\n          ) {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':')\n            this.localAddress = local[0]\n            this.localPort = Number(local[1])\n          }\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':')\n              ? 'IPv6'\n              : 'IPv4'\n          }\n\n          let remote =\n            remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address\n            this.remotePort = Number(remote.port)\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress\n            this.remotePort = Number(remote.portNumber)\n          } else if (\n            typeof selectedCandidatePair.googRemoteAddress === 'string'\n          ) {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\n            this.remoteAddress = remote[0]\n            this.remotePort = Number(remote[1])\n          }\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':')\n              ? 'IPv6'\n              : 'IPv4'\n          }\n\n          this._debug(\n            'connect local: %s:%s remote: %s:%s',\n            this.localAddress,\n            this.localPort,\n            this.remoteAddress,\n            this.remotePort\n          )\n        }\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(\n              candidatePairs[item.selectedCandidatePairId]\n            )\n          }\n\n          // Old implementations\n          if (\n            (item.type === 'googCandidatePair' &&\n              item.googActiveConnection === 'true') ||\n            ((item.type === 'candidatepair' ||\n              item.type === 'candidate-pair') &&\n              item.selected)\n          ) {\n            setSelectedCandidatePair(item)\n          }\n        })\n\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n        if (\n          !foundSelectedCandidatePair &&\n          (!Object.keys(candidatePairs).length ||\n            Object.keys(localCandidates).length)\n        ) {\n          setTimeout(findCandidatePair, 100)\n          return\n        } else {\n          this._connecting = false\n          this._connected = true\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk)\n          } catch (err) {\n            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))\n          }\n          this._chunk = null\n          this._debug('sent chunk from \"write before connect\"')\n\n          const cb = this._cb\n          this._cb = null\n          cb(null)\n        }\n\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150)\n          if (this._interval.unref) this._interval.unref()\n        }\n\n        this._debug('connect')\n        this.emit('connect')\n      })\n    }\n    findCandidatePair()\n  }\n\n  _onInterval () {\n    if (\n      !this._cb ||\n      !this._channel ||\n      this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT\n    ) {\n      return\n    }\n    this._onChannelBufferedAmountLow()\n  }\n\n  _onSignalingStateChange () {\n    if (this.destroyed) return\n\n    if (this._pc.signalingState === 'stable') {\n      this._isNegotiating = false\n\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender)\n        this._queuedNegotiation = true\n      })\n      this._sendersAwaitingStable = []\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue')\n        this._queuedNegotiation = false\n        this._needsNegotiation() // negotiate again\n      } else {\n        this._debug('negotiated')\n        this.emit('negotiated')\n      }\n    }\n\n    this._debug('signalingStateChange %s', this._pc.signalingState)\n    this.emit('signalingStateChange', this._pc.signalingState)\n  }\n\n  _onIceCandidate (event) {\n    if (this.destroyed) return\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        type: 'candidate',\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      })\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true\n      this.emit('_iceComplete')\n    }\n    // as soon as we've received one valid candidate start timeout\n    if (event.candidate) {\n      this._startIceCompleteTimeout()\n    }\n  }\n\n  _onChannelMessage (event) {\n    if (this.destroyed) return\n    let data = event.data\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\n    this.emit('data', data)\n  }\n\n  _onChannelBufferedAmountLow () {\n    if (this.destroyed || !this._cb) return\n    this._debug(\n      'ending backpressure: bufferedAmount %d',\n      this._channel.bufferedAmount\n    )\n    const cb = this._cb\n    this._cb = null\n    cb(null)\n  }\n\n  _onChannelOpen () {\n    if (this._connected || this.destroyed) return\n    this._debug('on channel open')\n    this._channelReady = true\n    this._maybeReady()\n  }\n\n  _onChannelClose () {\n    if (this.destroyed) return\n    this._debug('on channel close')\n    this.destroy()\n  }\n\n  _onTrack (event) {\n    if (this.destroyed) return\n\n    event.streams.forEach(eventStream => {\n      this._debug('on track')\n      this.emit('track', event.track, eventStream)\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      })\n\n      if (\n        this._remoteStreams.some(remoteStream => {\n          return remoteStream.id === eventStream.id\n        })\n      ) { return } // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream)\n      queueMicrotask(() => {\n        this._debug('on stream')\n        this.emit('stream', eventStream) // ensure all tracks have been added\n      })\n    })\n  }\n\n  _debug (...args) {\n    if (!this._doDebug) return\n    args[0] = '[' + this._id + '] ' + args[0]\n    console.log(...args)\n  }\n\n  // event emitter\n  on (key, listener) {\n    const map = this._map\n    if (!map.has(key)) map.set(key, new Set())\n    map.get(key).add(listener)\n  }\n\n  off (key, listener) {\n    const map = this._map\n    const listeners = map.get(key)\n    if (!listeners) return\n    listeners.delete(listener)\n    if (listeners.size === 0) map.delete(key)\n  }\n\n  once (key, listener) {\n    const listener_ = (...args) => {\n      this.off(key, listener_)\n      listener(...args)\n    }\n    this.on(key, listener_)\n  }\n\n  emit (key, ...args) {\n    const map = this._map\n    if (!map.has(key)) return\n    for (const listener of map.get(key)) {\n      try {\n        listener(...args)\n      } catch (err) {\n        console.error(err)\n      }\n    }\n  }\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      urls: [\n        'stun:stun.l.google.com:19302',\n        'stun:global.stun.twilio.com:3478'\n      ]\n    }\n  ],\n  sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\n// module.exports = Peer\nexport default Peer\n","import {decodeBytes, encodeBytes} from './utils.js'\n\nconst algo = 'AES-CBC'\n\nconst pack = buff => btoa(String.fromCharCode.apply(null, new Uint8Array(buff)))\n\nconst unpack = packed => {\n  const str = atob(packed)\n\n  return new Uint8Array(str.length).map((_, i) => str.charCodeAt(i)).buffer\n}\n\nexport const genKey = async (secret, ns) =>\n  crypto.subtle.importKey(\n    'raw',\n    await crypto.subtle.digest(\n      {name: 'SHA-256'},\n      encodeBytes(`${secret}:${ns}`)\n    ),\n    {name: algo},\n    false,\n    ['encrypt', 'decrypt']\n  )\n\nexport const encrypt = async (keyP, plaintext) => {\n  const iv = crypto.getRandomValues(new Uint8Array(16))\n\n  return JSON.stringify({\n    c: pack(\n      await crypto.subtle.encrypt(\n        {name: algo, iv},\n        await keyP,\n        encodeBytes(plaintext)\n      )\n    ),\n    iv: [...iv]\n  })\n}\n\nexport const decrypt = async (keyP, raw) => {\n  const {c, iv} = JSON.parse(raw)\n\n  return decodeBytes(\n    await crypto.subtle.decrypt(\n      {name: algo, iv: new Uint8Array(iv)},\n      await keyP,\n      unpack(c)\n    )\n  )\n}\n"],"names":["$dad545c909cfec2d$var$room","$dad545c909cfec2d$var$sendPic","$dad545c909cfec2d$var$getPic","$dad545c909cfec2d$var$sendCameraSettings","$dad545c909cfec2d$var$getCameraSettings","$dad545c909cfec2d$var$setZoom","$dad545c909cfec2d$var$getZoom","$dad545c909cfec2d$var$takePictureEvent","$dad545c909cfec2d$var$getTakePictureEvent","f","$9dfd2262e4ffe054$var$randombytes","size","array","Uint8Array","i","Math","random","$9dfd2262e4ffe054$var$getBrowserRTC","globalThis","wrtc","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","$9dfd2262e4ffe054$var$errCode","err","code","Object","defineProperty","value","enumerable","configurable","$9dfd2262e4ffe054$var$filterTrickle","sdp","replace","$9dfd2262e4ffe054$var$Peer","constructor","opts","_map","Map","_id","toString","slice","_doDebug","debug","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","assign","offerOptions","answerOptions","sdpTransform","streams","stream","trickle","undefined","allowHalfTrickle","iceCompleteTimeout","destroyed","destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_wrtc","window","Error","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_senderMap","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","_pc","destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","catch","_setupData","channel","createDataChannel","ondatachannel","forEach","addStream","ontrack","_onTrack","_needsNegotiation","bufferSize","bufferedAmount","connected","readyState","address","port","family","signal","data","JSON","parse","renegotiate","transceiverRequest","addTransceiver","kind","init","candidate","remoteDescription","type","_addIceCandidate","push","setRemoteDescription","then","_createAnswer","iceCandidateObj","addIceCandidate","endsWith","console","warn","send","chunk","emit","getTracks","track","addTrack","submap","get","sender","removed","set","replaceTrack","oldTrack","newTrack","removeTrack","name","removeStream","queueMicrotask","negotiate","setTimeout","_createOffer","message","clearInterval","close","onmessage","onopen","onclose","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","isClosing","setInterval","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","setLocalDescription","once","_requestMissingTransceivers","getTransceivers","transceiver","mid","requested","createAnswer","answer","sendAnswer","connectionState","iceConnectionState","iceGatheringState","_maybeReady","getStats","cb","flattenValues","report","prototype","call","values","length","res","reports","result","names","stat","id","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","Number","ipAddress","portNumber","googLocalAddress","split","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","keys","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","ArrayBuffer","eventStream","some","remoteStream","args","log","on","key","listener","map","has","Set","add","off","listeners","delete","listener_","error","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","$42a97e6b757c21d9$var$charSet","$42a97e6b757c21d9$export$faba228f15d9c316","peer","onData","__earlyDataBuffer","$42a97e6b757c21d9$export$4bf9923669ad6c63","__drainEarlyData","$42a97e6b757c21d9$export$87d45d9755ebb726","n","Array","fill","floor","join","$42a97e6b757c21d9$export$cc42576d343e0f6a","$42a97e6b757c21d9$export$d01767fa86c38c2d","$42a97e6b757c21d9$export$ed97f33186d4b816","$42a97e6b757c21d9$export$68c286be0e7e55b7","entries","$42a97e6b757c21d9$export$3e9f948b41964866","fromEntries","$42a97e6b757c21d9$export$5150077fc2e7c662","$42a97e6b757c21d9$export$b50b6e108474309b","$42a97e6b757c21d9$export$5575a5c000f2af79","msg","$42a97e6b757c21d9$export$2589e87d78677b0d","txt","TextEncoder","encode","$42a97e6b757c21d9$export$c97600adfa527f5b","buffer","TextDecoder","decode","k","$42a97e6b757c21d9$export$37be945df5c81949","defaults","defaultN","relayUrls","relayRedundancy","$42a97e6b757c21d9$export$e772c8ff12451969","ms","Promise","$4dd9fb32b9ed9581$var$TypedArray","getPrototypeOf","$4dd9fb32b9ed9581$var$buffLowEvent","$4dd9fb32b9ed9581$export$2e2bcd8739ae039","onPeer","onSelfLeave","peerMap","actions","pendingTransmissions","pendingPongs","pendingStreamMetas","pendingTrackMetas","iterate","targets","isArray","flatMap","exitPeer","onPeerLeave","makeAction","setOnComplete","setOnProgress","typeBytes","byteLength","typeBytesPadded","nonce","onComplete","onProgress","meta","isJson","isBlob","Blob","isBinary","arrayBuffer","stringify","metaEncoded","chunkTotal","ceil","chunks","_","isLast","isMeta","$4dd9fb32b9ed9581$var$payloadIndex","$4dd9fb32b9ed9581$var$progressIndex","$4dd9fb32b9ed9581$var$chunkSize","$4dd9fb32b9ed9581$var$typeIndex","$4dd9fb32b9ed9581$var$nonceIndex","round","$4dd9fb32b9ed9581$var$tagIndex","subarray","all","chan","chunkN","next","removeEventListener","addEventListener","handleData","replaceAll","tag","progress","payload","target","full","reduce","a","c","text","sendPing","getPing","sendPong","getPong","sendSignal","getSignal","sendStreamMeta","getStreamMeta","sendTrackMeta","getTrackMeta","onPeerJoin","onPeerStream","onPeerTrack","bind","e","ping","start","Date","now","leave","getPeers","$dd87bb707555415a$var$algo","$dd87bb707555415a$var$pack","buff","btoa","String","fromCharCode","apply","$dd87bb707555415a$var$unpack","packed","str","atob","charCodeAt","$dd87bb707555415a$export$ceb27d5ba53e5cf8","secret","ns","crypto","subtle","importKey","digest","$dd87bb707555415a$export$5b0f6292f11d1d18","keyP","plaintext","iv","getRandomValues","encrypt","$dd87bb707555415a$export$e85a0c9a1067c5d3","raw","decrypt","$1098bf72ad57e222$var$occupiedRooms","$1098bf72ad57e222$var$socketPromises","$1098bf72ad57e222$var$sockets","$1098bf72ad57e222$var$socketRetryTimeouts","$1098bf72ad57e222$var$socketListeners","$1098bf72ad57e222$var$trackerAction","$1098bf72ad57e222$var$defaultRelayUrls","$1098bf72ad57e222$export$767472c72ffc2784","offerPool","trackerUrls","trackerRedundancy","connectedPeers","password","infoHashP","appId","from","b","makeOffers","howMany","rtcConfig","offerP","onSocketMessage","socket","val","infoHash","info_hash","peer_id","errMsg","url","interval","announceSecs","announceInterval","announceAll","offer_id","handledOffers","action","to_peer_id","connect","onConnect","onDisconnect","announce","numwant","offers","makeSocket","forced","WebSocket","$1098bf72ad57e222$var$trackerRetrySecs","cleanPool","OPEN","CONNECTING","offerId","onPeerConnect","peerId","occupiedRooms","firebaseApp","$dad545c909cfec2d$var$settings","roomId","isCamera","$dad545c909cfec2d$var$load_state","url_hash","location","hash","substring","$dad545c909cfec2d$var$deserialize","string","decodeURIComponent","$dad545c909cfec2d$var$roomIdInput","$dad545c909cfec2d$var$isCameraInput","checked","navigator","mediaDevices","getUserMedia","audio","video","selfStream","getVideoTracks","capabilities","getCapabilities","settings","getSettings","min","zoom","max","step","applyConstraints","advanced","zoomLevel","imageCapture","ImageCapture","takePhoto","blob","$dad545c909cfec2d$var$zoomInput","peerID","fileUrl","URL","createObjectURL","anchorElement","document","createElement","href","download","style","display","body","appendChild","click","remove","revokeObjectURL","$dad545c909cfec2d$var$video","srcObject","play","$dad545c909cfec2d$var$form","getElementById","$dad545c909cfec2d$var$shootInput","onchange","onclick","onsubmit","preventDefault","FormData","encodeURIComponent","reload"],"version":3,"file":"index.44cdc2bf.js.map"}